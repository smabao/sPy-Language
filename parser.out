Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    OPENBRACE
    is
    DBLLIT
    CHRLIT
    UNDERSCORE
    try
    for
    call
    COMMA
    CLOSEBRACE
    do
    MULTI_COMMENT
    break
    FLTLIT
    SINGLE_COMMENT
    while
    BOOLEAN
    NOT
    QUOTATION

Grammar

Rule 0     S' -> main_program
Rule 1     main_program -> start OPENCURLY statement CLOSECURLY end
Rule 2     statement -> empty
Rule 3     empty -> <empty>
Rule 4     statement -> statement_list
Rule 5     statement_list -> statement
Rule 6     statement_list -> statement statement_list
Rule 7     statement -> VAR ASSIGN expression TILDE
Rule 8     statement -> expression TILDE
Rule 9     statement -> def VAR OPENPAR parameter CLOSEPAR OPENCURLY statement CLOSECURLY end_def
Rule 10    parameter -> int VAR
Rule 11    parameter -> string VAR
Rule 12    statement -> class VAR OPENCURLY statement CLOSECURLY
Rule 13    statement -> VAR ASSIGN expression TILDE scan OPENPAR VAR CLOSEPAR TILDE
Rule 14    statement -> VAR ASSIGN STRLIT TILDE scan OPENPAR VAR CLOSEPAR TILDE
Rule 15    statement -> VAR ASSIGN expression TILDE return OPENPAR VAR CLOSEPAR TILDE
Rule 16    statement -> VAR ASSIGN STRLIT TILDE return OPENPAR VAR CLOSEPAR TILDE
Rule 17    statement -> print OPENPAR expression CLOSEPAR TILDE
Rule 18    statement -> print OPENPAR STRLIT CLOSEPAR TILDE
Rule 19    statement -> VAR ASSIGN expression TILDE print OPENPAR VAR CLOSEPAR TILDE
Rule 20    statement -> VAR ASSIGN STRLIT TILDE print OPENPAR VAR CLOSEPAR TILDE
Rule 21    statement -> if_statement
Rule 22    if_statement -> if OPENPAR boolean CLOSEPAR OPENCURLY statement CLOSECURLY
Rule 23    if_statement -> if OPENPAR boolean CLOSEPAR OPENCURLY statement CLOSECURLY else OPENCURLY statement CLOSECURLY
Rule 24    expression -> term
Rule 25    expression -> boolean
Rule 26    boolean -> expression GT term
Rule 27    boolean -> expression GEQ term
Rule 28    boolean -> expression LT term
Rule 29    boolean -> expression LEQ term
Rule 30    boolean -> expression EQ term
Rule 31    boolean -> expression NEQ term
Rule 32    boolean -> expression AND term
Rule 33    boolean -> expression OR term
Rule 34    expression -> expression PLUS term
Rule 35    expression -> expression MINUS term
Rule 36    term -> term MUL factor
Rule 37    term -> term DIV factor
Rule 38    term -> term MOD factor
Rule 39    term -> STRLIT
Rule 40    term -> factor
Rule 41    factor -> INTLIT
Rule 42    factor -> OPENPAR expression CLOSEPAR

Terminals, with rules where they appear

AND                  : 32
ASSIGN               : 7 13 14 15 16 19 20
BOOLEAN              : 
CHRLIT               : 
CLOSEBRACE           : 
CLOSECURLY           : 1 9 12 22 23 23
CLOSEPAR             : 9 13 14 15 16 17 18 19 20 22 23 42
COMMA                : 
DBLLIT               : 
DIV                  : 37
EQ                   : 30
FLTLIT               : 
GEQ                  : 27
GT                   : 26
INTLIT               : 41
LEQ                  : 29
LT                   : 28
MINUS                : 35
MOD                  : 38
MUL                  : 36
MULTI_COMMENT        : 
NEQ                  : 31
NOT                  : 
OPENBRACE            : 
OPENCURLY            : 1 9 12 22 23 23
OPENPAR              : 9 13 14 15 16 17 18 19 20 22 23 42
OR                   : 33
PLUS                 : 34
QUOTATION            : 
SINGLE_COMMENT       : 
STRLIT               : 14 16 18 20 39
TILDE                : 7 8 13 13 14 14 15 15 16 16 17 18 19 19 20 20
UNDERSCORE           : 
VAR                  : 7 9 10 11 12 13 13 14 14 15 15 16 16 19 19 20 20
break                : 
call                 : 
class                : 12
def                  : 9
do                   : 
else                 : 23
end                  : 1
end_def              : 9
error                : 
for                  : 
if                   : 22 23
int                  : 10
is                   : 
print                : 17 18 19 20
return               : 15 16
scan                 : 13 14
start                : 1
string               : 11
try                  : 
while                : 

Nonterminals, with rules where they appear

boolean              : 22 23 25
empty                : 2
expression           : 7 8 13 15 17 19 26 27 28 29 30 31 32 33 34 35 42
factor               : 36 37 38 40
if_statement         : 21
main_program         : 0
parameter            : 9
statement            : 1 5 6 9 12 22 23 23
statement_list       : 4 6
term                 : 24 26 27 28 29 30 31 32 33 34 35 36 37 38

Parsing method: LALR

state 0

    (0) S' -> . main_program
    (1) main_program -> . start OPENCURLY statement CLOSECURLY end

    start           shift and go to state 1

    main_program                   shift and go to state 2

state 1

    (1) main_program -> start . OPENCURLY statement CLOSECURLY end

    OPENCURLY       shift and go to state 3


state 2

    (0) S' -> main_program .



state 3

    (1) main_program -> start OPENCURLY . statement CLOSECURLY end
    (2) statement -> . empty
    (4) statement -> . statement_list
    (7) statement -> . VAR ASSIGN expression TILDE
    (8) statement -> . expression TILDE
    (9) statement -> . def VAR OPENPAR parameter CLOSEPAR OPENCURLY statement CLOSECURLY end_def
    (12) statement -> . class VAR OPENCURLY statement CLOSECURLY
    (13) statement -> . VAR ASSIGN expression TILDE scan OPENPAR VAR CLOSEPAR TILDE
    (14) statement -> . VAR ASSIGN STRLIT TILDE scan OPENPAR VAR CLOSEPAR TILDE
    (15) statement -> . VAR ASSIGN expression TILDE return OPENPAR VAR CLOSEPAR TILDE
    (16) statement -> . VAR ASSIGN STRLIT TILDE return OPENPAR VAR CLOSEPAR TILDE
    (17) statement -> . print OPENPAR expression CLOSEPAR TILDE
    (18) statement -> . print OPENPAR STRLIT CLOSEPAR TILDE
    (19) statement -> . VAR ASSIGN expression TILDE print OPENPAR VAR CLOSEPAR TILDE
    (20) statement -> . VAR ASSIGN STRLIT TILDE print OPENPAR VAR CLOSEPAR TILDE
    (21) statement -> . if_statement
    (3) empty -> .
    (5) statement_list -> . statement
    (6) statement_list -> . statement statement_list
    (24) expression -> . term
    (25) expression -> . boolean
    (34) expression -> . expression PLUS term
    (35) expression -> . expression MINUS term
    (22) if_statement -> . if OPENPAR boolean CLOSEPAR OPENCURLY statement CLOSECURLY
    (23) if_statement -> . if OPENPAR boolean CLOSEPAR OPENCURLY statement CLOSECURLY else OPENCURLY statement CLOSECURLY
    (36) term -> . term MUL factor
    (37) term -> . term DIV factor
    (38) term -> . term MOD factor
    (39) term -> . STRLIT
    (40) term -> . factor
    (26) boolean -> . expression GT term
    (27) boolean -> . expression GEQ term
    (28) boolean -> . expression LT term
    (29) boolean -> . expression LEQ term
    (30) boolean -> . expression EQ term
    (31) boolean -> . expression NEQ term
    (32) boolean -> . expression AND term
    (33) boolean -> . expression OR term
    (41) factor -> . INTLIT
    (42) factor -> . OPENPAR expression CLOSEPAR

  ! shift/reduce conflict for VAR resolved as shift
  ! shift/reduce conflict for def resolved as shift
  ! shift/reduce conflict for class resolved as shift
  ! shift/reduce conflict for print resolved as shift
  ! shift/reduce conflict for if resolved as shift
  ! shift/reduce conflict for STRLIT resolved as shift
  ! shift/reduce conflict for INTLIT resolved as shift
  ! shift/reduce conflict for OPENPAR resolved as shift
    VAR             shift and go to state 14
    def             shift and go to state 19
    class           shift and go to state 15
    print           shift and go to state 9
    CLOSECURLY      reduce using rule 3 (empty -> .)
    if              shift and go to state 7
    STRLIT          shift and go to state 13
    INTLIT          shift and go to state 6
    OPENPAR         shift and go to state 4

  ! VAR             [ reduce using rule 3 (empty -> .) ]
  ! def             [ reduce using rule 3 (empty -> .) ]
  ! class           [ reduce using rule 3 (empty -> .) ]
  ! print           [ reduce using rule 3 (empty -> .) ]
  ! if              [ reduce using rule 3 (empty -> .) ]
  ! STRLIT          [ reduce using rule 3 (empty -> .) ]
  ! INTLIT          [ reduce using rule 3 (empty -> .) ]
  ! OPENPAR         [ reduce using rule 3 (empty -> .) ]

    term                           shift and go to state 16
    expression                     shift and go to state 18
    boolean                        shift and go to state 5
    statement                      shift and go to state 8
    factor                         shift and go to state 12
    statement_list                 shift and go to state 17
    if_statement                   shift and go to state 10
    empty                          shift and go to state 11

state 4

    (42) factor -> OPENPAR . expression CLOSEPAR
    (24) expression -> . term
    (25) expression -> . boolean
    (34) expression -> . expression PLUS term
    (35) expression -> . expression MINUS term
    (36) term -> . term MUL factor
    (37) term -> . term DIV factor
    (38) term -> . term MOD factor
    (39) term -> . STRLIT
    (40) term -> . factor
    (26) boolean -> . expression GT term
    (27) boolean -> . expression GEQ term
    (28) boolean -> . expression LT term
    (29) boolean -> . expression LEQ term
    (30) boolean -> . expression EQ term
    (31) boolean -> . expression NEQ term
    (32) boolean -> . expression AND term
    (33) boolean -> . expression OR term
    (41) factor -> . INTLIT
    (42) factor -> . OPENPAR expression CLOSEPAR

    STRLIT          shift and go to state 13
    INTLIT          shift and go to state 6
    OPENPAR         shift and go to state 4

    term                           shift and go to state 16
    boolean                        shift and go to state 5
    expression                     shift and go to state 20
    factor                         shift and go to state 12

state 5

    (25) expression -> boolean .

    TILDE           reduce using rule 25 (expression -> boolean .)
    PLUS            reduce using rule 25 (expression -> boolean .)
    MINUS           reduce using rule 25 (expression -> boolean .)
    GT              reduce using rule 25 (expression -> boolean .)
    GEQ             reduce using rule 25 (expression -> boolean .)
    LT              reduce using rule 25 (expression -> boolean .)
    LEQ             reduce using rule 25 (expression -> boolean .)
    EQ              reduce using rule 25 (expression -> boolean .)
    NEQ             reduce using rule 25 (expression -> boolean .)
    AND             reduce using rule 25 (expression -> boolean .)
    OR              reduce using rule 25 (expression -> boolean .)
    CLOSEPAR        reduce using rule 25 (expression -> boolean .)


state 6

    (41) factor -> INTLIT .

    MUL             reduce using rule 41 (factor -> INTLIT .)
    DIV             reduce using rule 41 (factor -> INTLIT .)
    MOD             reduce using rule 41 (factor -> INTLIT .)
    TILDE           reduce using rule 41 (factor -> INTLIT .)
    PLUS            reduce using rule 41 (factor -> INTLIT .)
    MINUS           reduce using rule 41 (factor -> INTLIT .)
    GT              reduce using rule 41 (factor -> INTLIT .)
    GEQ             reduce using rule 41 (factor -> INTLIT .)
    LT              reduce using rule 41 (factor -> INTLIT .)
    LEQ             reduce using rule 41 (factor -> INTLIT .)
    EQ              reduce using rule 41 (factor -> INTLIT .)
    NEQ             reduce using rule 41 (factor -> INTLIT .)
    AND             reduce using rule 41 (factor -> INTLIT .)
    OR              reduce using rule 41 (factor -> INTLIT .)
    CLOSEPAR        reduce using rule 41 (factor -> INTLIT .)


state 7

    (22) if_statement -> if . OPENPAR boolean CLOSEPAR OPENCURLY statement CLOSECURLY
    (23) if_statement -> if . OPENPAR boolean CLOSEPAR OPENCURLY statement CLOSECURLY else OPENCURLY statement CLOSECURLY

    OPENPAR         shift and go to state 21


state 8

    (1) main_program -> start OPENCURLY statement . CLOSECURLY end
    (5) statement_list -> statement .
    (6) statement_list -> statement . statement_list
    (5) statement_list -> . statement
    (6) statement_list -> . statement statement_list
    (2) statement -> . empty
    (4) statement -> . statement_list
    (7) statement -> . VAR ASSIGN expression TILDE
    (8) statement -> . expression TILDE
    (9) statement -> . def VAR OPENPAR parameter CLOSEPAR OPENCURLY statement CLOSECURLY end_def
    (12) statement -> . class VAR OPENCURLY statement CLOSECURLY
    (13) statement -> . VAR ASSIGN expression TILDE scan OPENPAR VAR CLOSEPAR TILDE
    (14) statement -> . VAR ASSIGN STRLIT TILDE scan OPENPAR VAR CLOSEPAR TILDE
    (15) statement -> . VAR ASSIGN expression TILDE return OPENPAR VAR CLOSEPAR TILDE
    (16) statement -> . VAR ASSIGN STRLIT TILDE return OPENPAR VAR CLOSEPAR TILDE
    (17) statement -> . print OPENPAR expression CLOSEPAR TILDE
    (18) statement -> . print OPENPAR STRLIT CLOSEPAR TILDE
    (19) statement -> . VAR ASSIGN expression TILDE print OPENPAR VAR CLOSEPAR TILDE
    (20) statement -> . VAR ASSIGN STRLIT TILDE print OPENPAR VAR CLOSEPAR TILDE
    (21) statement -> . if_statement
    (3) empty -> .
    (24) expression -> . term
    (25) expression -> . boolean
    (34) expression -> . expression PLUS term
    (35) expression -> . expression MINUS term
    (22) if_statement -> . if OPENPAR boolean CLOSEPAR OPENCURLY statement CLOSECURLY
    (23) if_statement -> . if OPENPAR boolean CLOSEPAR OPENCURLY statement CLOSECURLY else OPENCURLY statement CLOSECURLY
    (36) term -> . term MUL factor
    (37) term -> . term DIV factor
    (38) term -> . term MOD factor
    (39) term -> . STRLIT
    (40) term -> . factor
    (26) boolean -> . expression GT term
    (27) boolean -> . expression GEQ term
    (28) boolean -> . expression LT term
    (29) boolean -> . expression LEQ term
    (30) boolean -> . expression EQ term
    (31) boolean -> . expression NEQ term
    (32) boolean -> . expression AND term
    (33) boolean -> . expression OR term
    (41) factor -> . INTLIT
    (42) factor -> . OPENPAR expression CLOSEPAR

  ! shift/reduce conflict for CLOSECURLY resolved as shift
  ! shift/reduce conflict for VAR resolved as shift
  ! shift/reduce conflict for def resolved as shift
  ! shift/reduce conflict for class resolved as shift
  ! shift/reduce conflict for print resolved as shift
  ! shift/reduce conflict for CLOSECURLY resolved as shift
  ! shift/reduce conflict for VAR resolved as shift
  ! shift/reduce conflict for def resolved as shift
  ! shift/reduce conflict for class resolved as shift
  ! shift/reduce conflict for print resolved as shift
  ! reduce/reduce conflict for if resolved using rule 3 (empty -> .)
  ! reduce/reduce conflict for STRLIT resolved using rule 3 (empty -> .)
  ! reduce/reduce conflict for INTLIT resolved using rule 3 (empty -> .)
  ! reduce/reduce conflict for OPENPAR resolved using rule 3 (empty -> .)
  ! shift/reduce conflict for if resolved as shift
  ! shift/reduce conflict for STRLIT resolved as shift
  ! shift/reduce conflict for INTLIT resolved as shift
  ! shift/reduce conflict for OPENPAR resolved as shift
    CLOSECURLY      shift and go to state 22
    VAR             shift and go to state 14
    def             shift and go to state 19
    class           shift and go to state 15
    print           shift and go to state 9
    if              shift and go to state 7
    STRLIT          shift and go to state 13
    INTLIT          shift and go to state 6
    OPENPAR         shift and go to state 4

  ! CLOSECURLY      [ reduce using rule 5 (statement_list -> statement .) ]
  ! VAR             [ reduce using rule 5 (statement_list -> statement .) ]
  ! def             [ reduce using rule 5 (statement_list -> statement .) ]
  ! class           [ reduce using rule 5 (statement_list -> statement .) ]
  ! print           [ reduce using rule 5 (statement_list -> statement .) ]
  ! if              [ reduce using rule 5 (statement_list -> statement .) ]
  ! STRLIT          [ reduce using rule 5 (statement_list -> statement .) ]
  ! INTLIT          [ reduce using rule 5 (statement_list -> statement .) ]
  ! OPENPAR         [ reduce using rule 5 (statement_list -> statement .) ]
  ! CLOSECURLY      [ reduce using rule 3 (empty -> .) ]
  ! VAR             [ reduce using rule 3 (empty -> .) ]
  ! def             [ reduce using rule 3 (empty -> .) ]
  ! class           [ reduce using rule 3 (empty -> .) ]
  ! print           [ reduce using rule 3 (empty -> .) ]
  ! if              [ reduce using rule 3 (empty -> .) ]
  ! STRLIT          [ reduce using rule 3 (empty -> .) ]
  ! INTLIT          [ reduce using rule 3 (empty -> .) ]
  ! OPENPAR         [ reduce using rule 3 (empty -> .) ]

    term                           shift and go to state 16
    expression                     shift and go to state 18
    boolean                        shift and go to state 5
    statement                      shift and go to state 23
    factor                         shift and go to state 12
    statement_list                 shift and go to state 24
    if_statement                   shift and go to state 10
    empty                          shift and go to state 11

state 9

    (17) statement -> print . OPENPAR expression CLOSEPAR TILDE
    (18) statement -> print . OPENPAR STRLIT CLOSEPAR TILDE

    OPENPAR         shift and go to state 25


state 10

    (21) statement -> if_statement .

    CLOSECURLY      reduce using rule 21 (statement -> if_statement .)
    VAR             reduce using rule 21 (statement -> if_statement .)
    def             reduce using rule 21 (statement -> if_statement .)
    class           reduce using rule 21 (statement -> if_statement .)
    print           reduce using rule 21 (statement -> if_statement .)
    if              reduce using rule 21 (statement -> if_statement .)
    STRLIT          reduce using rule 21 (statement -> if_statement .)
    INTLIT          reduce using rule 21 (statement -> if_statement .)
    OPENPAR         reduce using rule 21 (statement -> if_statement .)


state 11

    (2) statement -> empty .

    CLOSECURLY      reduce using rule 2 (statement -> empty .)
    VAR             reduce using rule 2 (statement -> empty .)
    def             reduce using rule 2 (statement -> empty .)
    class           reduce using rule 2 (statement -> empty .)
    print           reduce using rule 2 (statement -> empty .)
    if              reduce using rule 2 (statement -> empty .)
    STRLIT          reduce using rule 2 (statement -> empty .)
    INTLIT          reduce using rule 2 (statement -> empty .)
    OPENPAR         reduce using rule 2 (statement -> empty .)


state 12

    (40) term -> factor .

    MUL             reduce using rule 40 (term -> factor .)
    DIV             reduce using rule 40 (term -> factor .)
    MOD             reduce using rule 40 (term -> factor .)
    TILDE           reduce using rule 40 (term -> factor .)
    PLUS            reduce using rule 40 (term -> factor .)
    MINUS           reduce using rule 40 (term -> factor .)
    GT              reduce using rule 40 (term -> factor .)
    GEQ             reduce using rule 40 (term -> factor .)
    LT              reduce using rule 40 (term -> factor .)
    LEQ             reduce using rule 40 (term -> factor .)
    EQ              reduce using rule 40 (term -> factor .)
    NEQ             reduce using rule 40 (term -> factor .)
    AND             reduce using rule 40 (term -> factor .)
    OR              reduce using rule 40 (term -> factor .)
    CLOSEPAR        reduce using rule 40 (term -> factor .)


state 13

    (39) term -> STRLIT .

    MUL             reduce using rule 39 (term -> STRLIT .)
    DIV             reduce using rule 39 (term -> STRLIT .)
    MOD             reduce using rule 39 (term -> STRLIT .)
    TILDE           reduce using rule 39 (term -> STRLIT .)
    PLUS            reduce using rule 39 (term -> STRLIT .)
    MINUS           reduce using rule 39 (term -> STRLIT .)
    GT              reduce using rule 39 (term -> STRLIT .)
    GEQ             reduce using rule 39 (term -> STRLIT .)
    LT              reduce using rule 39 (term -> STRLIT .)
    LEQ             reduce using rule 39 (term -> STRLIT .)
    EQ              reduce using rule 39 (term -> STRLIT .)
    NEQ             reduce using rule 39 (term -> STRLIT .)
    AND             reduce using rule 39 (term -> STRLIT .)
    OR              reduce using rule 39 (term -> STRLIT .)
    CLOSEPAR        reduce using rule 39 (term -> STRLIT .)


state 14

    (7) statement -> VAR . ASSIGN expression TILDE
    (13) statement -> VAR . ASSIGN expression TILDE scan OPENPAR VAR CLOSEPAR TILDE
    (14) statement -> VAR . ASSIGN STRLIT TILDE scan OPENPAR VAR CLOSEPAR TILDE
    (15) statement -> VAR . ASSIGN expression TILDE return OPENPAR VAR CLOSEPAR TILDE
    (16) statement -> VAR . ASSIGN STRLIT TILDE return OPENPAR VAR CLOSEPAR TILDE
    (19) statement -> VAR . ASSIGN expression TILDE print OPENPAR VAR CLOSEPAR TILDE
    (20) statement -> VAR . ASSIGN STRLIT TILDE print OPENPAR VAR CLOSEPAR TILDE

    ASSIGN          shift and go to state 26


state 15

    (12) statement -> class . VAR OPENCURLY statement CLOSECURLY

    VAR             shift and go to state 27


state 16

    (24) expression -> term .
    (36) term -> term . MUL factor
    (37) term -> term . DIV factor
    (38) term -> term . MOD factor

    TILDE           reduce using rule 24 (expression -> term .)
    PLUS            reduce using rule 24 (expression -> term .)
    MINUS           reduce using rule 24 (expression -> term .)
    GT              reduce using rule 24 (expression -> term .)
    GEQ             reduce using rule 24 (expression -> term .)
    LT              reduce using rule 24 (expression -> term .)
    LEQ             reduce using rule 24 (expression -> term .)
    EQ              reduce using rule 24 (expression -> term .)
    NEQ             reduce using rule 24 (expression -> term .)
    AND             reduce using rule 24 (expression -> term .)
    OR              reduce using rule 24 (expression -> term .)
    CLOSEPAR        reduce using rule 24 (expression -> term .)
    MUL             shift and go to state 28
    DIV             shift and go to state 30
    MOD             shift and go to state 29


state 17

    (4) statement -> statement_list .

    CLOSECURLY      reduce using rule 4 (statement -> statement_list .)
    VAR             reduce using rule 4 (statement -> statement_list .)
    def             reduce using rule 4 (statement -> statement_list .)
    class           reduce using rule 4 (statement -> statement_list .)
    print           reduce using rule 4 (statement -> statement_list .)
    if              reduce using rule 4 (statement -> statement_list .)
    STRLIT          reduce using rule 4 (statement -> statement_list .)
    INTLIT          reduce using rule 4 (statement -> statement_list .)
    OPENPAR         reduce using rule 4 (statement -> statement_list .)


state 18

    (8) statement -> expression . TILDE
    (34) expression -> expression . PLUS term
    (35) expression -> expression . MINUS term
    (26) boolean -> expression . GT term
    (27) boolean -> expression . GEQ term
    (28) boolean -> expression . LT term
    (29) boolean -> expression . LEQ term
    (30) boolean -> expression . EQ term
    (31) boolean -> expression . NEQ term
    (32) boolean -> expression . AND term
    (33) boolean -> expression . OR term

    TILDE           shift and go to state 39
    PLUS            shift and go to state 38
    MINUS           shift and go to state 40
    GT              shift and go to state 32
    GEQ             shift and go to state 34
    LT              shift and go to state 37
    LEQ             shift and go to state 36
    EQ              shift and go to state 33
    NEQ             shift and go to state 41
    AND             shift and go to state 31
    OR              shift and go to state 35


state 19

    (9) statement -> def . VAR OPENPAR parameter CLOSEPAR OPENCURLY statement CLOSECURLY end_def

    VAR             shift and go to state 42


state 20

    (42) factor -> OPENPAR expression . CLOSEPAR
    (34) expression -> expression . PLUS term
    (35) expression -> expression . MINUS term
    (26) boolean -> expression . GT term
    (27) boolean -> expression . GEQ term
    (28) boolean -> expression . LT term
    (29) boolean -> expression . LEQ term
    (30) boolean -> expression . EQ term
    (31) boolean -> expression . NEQ term
    (32) boolean -> expression . AND term
    (33) boolean -> expression . OR term

    CLOSEPAR        shift and go to state 43
    PLUS            shift and go to state 38
    MINUS           shift and go to state 40
    GT              shift and go to state 32
    GEQ             shift and go to state 34
    LT              shift and go to state 37
    LEQ             shift and go to state 36
    EQ              shift and go to state 33
    NEQ             shift and go to state 41
    AND             shift and go to state 31
    OR              shift and go to state 35


state 21

    (22) if_statement -> if OPENPAR . boolean CLOSEPAR OPENCURLY statement CLOSECURLY
    (23) if_statement -> if OPENPAR . boolean CLOSEPAR OPENCURLY statement CLOSECURLY else OPENCURLY statement CLOSECURLY
    (26) boolean -> . expression GT term
    (27) boolean -> . expression GEQ term
    (28) boolean -> . expression LT term
    (29) boolean -> . expression LEQ term
    (30) boolean -> . expression EQ term
    (31) boolean -> . expression NEQ term
    (32) boolean -> . expression AND term
    (33) boolean -> . expression OR term
    (24) expression -> . term
    (25) expression -> . boolean
    (34) expression -> . expression PLUS term
    (35) expression -> . expression MINUS term
    (36) term -> . term MUL factor
    (37) term -> . term DIV factor
    (38) term -> . term MOD factor
    (39) term -> . STRLIT
    (40) term -> . factor
    (41) factor -> . INTLIT
    (42) factor -> . OPENPAR expression CLOSEPAR

    STRLIT          shift and go to state 13
    INTLIT          shift and go to state 6
    OPENPAR         shift and go to state 4

    term                           shift and go to state 16
    boolean                        shift and go to state 44
    expression                     shift and go to state 45
    factor                         shift and go to state 12

state 22

    (1) main_program -> start OPENCURLY statement CLOSECURLY . end

    end             shift and go to state 46


state 23

    (5) statement_list -> statement .
    (6) statement_list -> statement . statement_list
    (5) statement_list -> . statement
    (6) statement_list -> . statement statement_list
    (2) statement -> . empty
    (4) statement -> . statement_list
    (7) statement -> . VAR ASSIGN expression TILDE
    (8) statement -> . expression TILDE
    (9) statement -> . def VAR OPENPAR parameter CLOSEPAR OPENCURLY statement CLOSECURLY end_def
    (12) statement -> . class VAR OPENCURLY statement CLOSECURLY
    (13) statement -> . VAR ASSIGN expression TILDE scan OPENPAR VAR CLOSEPAR TILDE
    (14) statement -> . VAR ASSIGN STRLIT TILDE scan OPENPAR VAR CLOSEPAR TILDE
    (15) statement -> . VAR ASSIGN expression TILDE return OPENPAR VAR CLOSEPAR TILDE
    (16) statement -> . VAR ASSIGN STRLIT TILDE return OPENPAR VAR CLOSEPAR TILDE
    (17) statement -> . print OPENPAR expression CLOSEPAR TILDE
    (18) statement -> . print OPENPAR STRLIT CLOSEPAR TILDE
    (19) statement -> . VAR ASSIGN expression TILDE print OPENPAR VAR CLOSEPAR TILDE
    (20) statement -> . VAR ASSIGN STRLIT TILDE print OPENPAR VAR CLOSEPAR TILDE
    (21) statement -> . if_statement
    (3) empty -> .
    (24) expression -> . term
    (25) expression -> . boolean
    (34) expression -> . expression PLUS term
    (35) expression -> . expression MINUS term
    (22) if_statement -> . if OPENPAR boolean CLOSEPAR OPENCURLY statement CLOSECURLY
    (23) if_statement -> . if OPENPAR boolean CLOSEPAR OPENCURLY statement CLOSECURLY else OPENCURLY statement CLOSECURLY
    (36) term -> . term MUL factor
    (37) term -> . term DIV factor
    (38) term -> . term MOD factor
    (39) term -> . STRLIT
    (40) term -> . factor
    (26) boolean -> . expression GT term
    (27) boolean -> . expression GEQ term
    (28) boolean -> . expression LT term
    (29) boolean -> . expression LEQ term
    (30) boolean -> . expression EQ term
    (31) boolean -> . expression NEQ term
    (32) boolean -> . expression AND term
    (33) boolean -> . expression OR term
    (41) factor -> . INTLIT
    (42) factor -> . OPENPAR expression CLOSEPAR

  ! shift/reduce conflict for VAR resolved as shift
  ! shift/reduce conflict for def resolved as shift
  ! shift/reduce conflict for class resolved as shift
  ! shift/reduce conflict for print resolved as shift
  ! reduce/reduce conflict for CLOSECURLY resolved using rule 3 (empty -> .)
  ! shift/reduce conflict for VAR resolved as shift
  ! shift/reduce conflict for def resolved as shift
  ! shift/reduce conflict for class resolved as shift
  ! shift/reduce conflict for print resolved as shift
  ! reduce/reduce conflict for if resolved using rule 3 (empty -> .)
  ! reduce/reduce conflict for STRLIT resolved using rule 3 (empty -> .)
  ! reduce/reduce conflict for INTLIT resolved using rule 3 (empty -> .)
  ! reduce/reduce conflict for OPENPAR resolved using rule 3 (empty -> .)
  ! shift/reduce conflict for if resolved as shift
  ! shift/reduce conflict for STRLIT resolved as shift
  ! shift/reduce conflict for INTLIT resolved as shift
  ! shift/reduce conflict for OPENPAR resolved as shift
    VAR             shift and go to state 14
    def             shift and go to state 19
    class           shift and go to state 15
    print           shift and go to state 9
    CLOSECURLY      reduce using rule 3 (empty -> .)
    if              shift and go to state 7
    STRLIT          shift and go to state 13
    INTLIT          shift and go to state 6
    OPENPAR         shift and go to state 4

  ! CLOSECURLY      [ reduce using rule 5 (statement_list -> statement .) ]
  ! VAR             [ reduce using rule 5 (statement_list -> statement .) ]
  ! def             [ reduce using rule 5 (statement_list -> statement .) ]
  ! class           [ reduce using rule 5 (statement_list -> statement .) ]
  ! print           [ reduce using rule 5 (statement_list -> statement .) ]
  ! if              [ reduce using rule 5 (statement_list -> statement .) ]
  ! STRLIT          [ reduce using rule 5 (statement_list -> statement .) ]
  ! INTLIT          [ reduce using rule 5 (statement_list -> statement .) ]
  ! OPENPAR         [ reduce using rule 5 (statement_list -> statement .) ]
  ! VAR             [ reduce using rule 3 (empty -> .) ]
  ! def             [ reduce using rule 3 (empty -> .) ]
  ! class           [ reduce using rule 3 (empty -> .) ]
  ! print           [ reduce using rule 3 (empty -> .) ]
  ! if              [ reduce using rule 3 (empty -> .) ]
  ! STRLIT          [ reduce using rule 3 (empty -> .) ]
  ! INTLIT          [ reduce using rule 3 (empty -> .) ]
  ! OPENPAR         [ reduce using rule 3 (empty -> .) ]

    term                           shift and go to state 16
    expression                     shift and go to state 18
    boolean                        shift and go to state 5
    statement                      shift and go to state 23
    factor                         shift and go to state 12
    statement_list                 shift and go to state 24
    if_statement                   shift and go to state 10
    empty                          shift and go to state 11

state 24

    (6) statement_list -> statement statement_list .
    (4) statement -> statement_list .

  ! reduce/reduce conflict for CLOSECURLY resolved using rule 4 (statement -> statement_list .)
  ! reduce/reduce conflict for VAR resolved using rule 4 (statement -> statement_list .)
  ! reduce/reduce conflict for def resolved using rule 4 (statement -> statement_list .)
  ! reduce/reduce conflict for class resolved using rule 4 (statement -> statement_list .)
  ! reduce/reduce conflict for print resolved using rule 4 (statement -> statement_list .)
  ! reduce/reduce conflict for if resolved using rule 4 (statement -> statement_list .)
  ! reduce/reduce conflict for STRLIT resolved using rule 4 (statement -> statement_list .)
  ! reduce/reduce conflict for INTLIT resolved using rule 4 (statement -> statement_list .)
  ! reduce/reduce conflict for OPENPAR resolved using rule 4 (statement -> statement_list .)
    CLOSECURLY      reduce using rule 4 (statement -> statement_list .)
    VAR             reduce using rule 4 (statement -> statement_list .)
    def             reduce using rule 4 (statement -> statement_list .)
    class           reduce using rule 4 (statement -> statement_list .)
    print           reduce using rule 4 (statement -> statement_list .)
    if              reduce using rule 4 (statement -> statement_list .)
    STRLIT          reduce using rule 4 (statement -> statement_list .)
    INTLIT          reduce using rule 4 (statement -> statement_list .)
    OPENPAR         reduce using rule 4 (statement -> statement_list .)

  ! CLOSECURLY      [ reduce using rule 6 (statement_list -> statement statement_list .) ]
  ! VAR             [ reduce using rule 6 (statement_list -> statement statement_list .) ]
  ! def             [ reduce using rule 6 (statement_list -> statement statement_list .) ]
  ! class           [ reduce using rule 6 (statement_list -> statement statement_list .) ]
  ! print           [ reduce using rule 6 (statement_list -> statement statement_list .) ]
  ! if              [ reduce using rule 6 (statement_list -> statement statement_list .) ]
  ! STRLIT          [ reduce using rule 6 (statement_list -> statement statement_list .) ]
  ! INTLIT          [ reduce using rule 6 (statement_list -> statement statement_list .) ]
  ! OPENPAR         [ reduce using rule 6 (statement_list -> statement statement_list .) ]


state 25

    (17) statement -> print OPENPAR . expression CLOSEPAR TILDE
    (18) statement -> print OPENPAR . STRLIT CLOSEPAR TILDE
    (24) expression -> . term
    (25) expression -> . boolean
    (34) expression -> . expression PLUS term
    (35) expression -> . expression MINUS term
    (36) term -> . term MUL factor
    (37) term -> . term DIV factor
    (38) term -> . term MOD factor
    (39) term -> . STRLIT
    (40) term -> . factor
    (26) boolean -> . expression GT term
    (27) boolean -> . expression GEQ term
    (28) boolean -> . expression LT term
    (29) boolean -> . expression LEQ term
    (30) boolean -> . expression EQ term
    (31) boolean -> . expression NEQ term
    (32) boolean -> . expression AND term
    (33) boolean -> . expression OR term
    (41) factor -> . INTLIT
    (42) factor -> . OPENPAR expression CLOSEPAR

    STRLIT          shift and go to state 47
    INTLIT          shift and go to state 6
    OPENPAR         shift and go to state 4

    term                           shift and go to state 16
    boolean                        shift and go to state 5
    expression                     shift and go to state 48
    factor                         shift and go to state 12

state 26

    (7) statement -> VAR ASSIGN . expression TILDE
    (13) statement -> VAR ASSIGN . expression TILDE scan OPENPAR VAR CLOSEPAR TILDE
    (14) statement -> VAR ASSIGN . STRLIT TILDE scan OPENPAR VAR CLOSEPAR TILDE
    (15) statement -> VAR ASSIGN . expression TILDE return OPENPAR VAR CLOSEPAR TILDE
    (16) statement -> VAR ASSIGN . STRLIT TILDE return OPENPAR VAR CLOSEPAR TILDE
    (19) statement -> VAR ASSIGN . expression TILDE print OPENPAR VAR CLOSEPAR TILDE
    (20) statement -> VAR ASSIGN . STRLIT TILDE print OPENPAR VAR CLOSEPAR TILDE
    (24) expression -> . term
    (25) expression -> . boolean
    (34) expression -> . expression PLUS term
    (35) expression -> . expression MINUS term
    (36) term -> . term MUL factor
    (37) term -> . term DIV factor
    (38) term -> . term MOD factor
    (39) term -> . STRLIT
    (40) term -> . factor
    (26) boolean -> . expression GT term
    (27) boolean -> . expression GEQ term
    (28) boolean -> . expression LT term
    (29) boolean -> . expression LEQ term
    (30) boolean -> . expression EQ term
    (31) boolean -> . expression NEQ term
    (32) boolean -> . expression AND term
    (33) boolean -> . expression OR term
    (41) factor -> . INTLIT
    (42) factor -> . OPENPAR expression CLOSEPAR

    STRLIT          shift and go to state 49
    INTLIT          shift and go to state 6
    OPENPAR         shift and go to state 4

    term                           shift and go to state 16
    boolean                        shift and go to state 5
    expression                     shift and go to state 50
    factor                         shift and go to state 12

state 27

    (12) statement -> class VAR . OPENCURLY statement CLOSECURLY

    OPENCURLY       shift and go to state 51


state 28

    (36) term -> term MUL . factor
    (41) factor -> . INTLIT
    (42) factor -> . OPENPAR expression CLOSEPAR

    INTLIT          shift and go to state 6
    OPENPAR         shift and go to state 4

    factor                         shift and go to state 52

state 29

    (38) term -> term MOD . factor
    (41) factor -> . INTLIT
    (42) factor -> . OPENPAR expression CLOSEPAR

    INTLIT          shift and go to state 6
    OPENPAR         shift and go to state 4

    factor                         shift and go to state 53

state 30

    (37) term -> term DIV . factor
    (41) factor -> . INTLIT
    (42) factor -> . OPENPAR expression CLOSEPAR

    INTLIT          shift and go to state 6
    OPENPAR         shift and go to state 4

    factor                         shift and go to state 54

state 31

    (32) boolean -> expression AND . term
    (36) term -> . term MUL factor
    (37) term -> . term DIV factor
    (38) term -> . term MOD factor
    (39) term -> . STRLIT
    (40) term -> . factor
    (41) factor -> . INTLIT
    (42) factor -> . OPENPAR expression CLOSEPAR

    STRLIT          shift and go to state 13
    INTLIT          shift and go to state 6
    OPENPAR         shift and go to state 4

    term                           shift and go to state 55
    factor                         shift and go to state 12

state 32

    (26) boolean -> expression GT . term
    (36) term -> . term MUL factor
    (37) term -> . term DIV factor
    (38) term -> . term MOD factor
    (39) term -> . STRLIT
    (40) term -> . factor
    (41) factor -> . INTLIT
    (42) factor -> . OPENPAR expression CLOSEPAR

    STRLIT          shift and go to state 13
    INTLIT          shift and go to state 6
    OPENPAR         shift and go to state 4

    term                           shift and go to state 56
    factor                         shift and go to state 12

state 33

    (30) boolean -> expression EQ . term
    (36) term -> . term MUL factor
    (37) term -> . term DIV factor
    (38) term -> . term MOD factor
    (39) term -> . STRLIT
    (40) term -> . factor
    (41) factor -> . INTLIT
    (42) factor -> . OPENPAR expression CLOSEPAR

    STRLIT          shift and go to state 13
    INTLIT          shift and go to state 6
    OPENPAR         shift and go to state 4

    term                           shift and go to state 57
    factor                         shift and go to state 12

state 34

    (27) boolean -> expression GEQ . term
    (36) term -> . term MUL factor
    (37) term -> . term DIV factor
    (38) term -> . term MOD factor
    (39) term -> . STRLIT
    (40) term -> . factor
    (41) factor -> . INTLIT
    (42) factor -> . OPENPAR expression CLOSEPAR

    STRLIT          shift and go to state 13
    INTLIT          shift and go to state 6
    OPENPAR         shift and go to state 4

    term                           shift and go to state 58
    factor                         shift and go to state 12

state 35

    (33) boolean -> expression OR . term
    (36) term -> . term MUL factor
    (37) term -> . term DIV factor
    (38) term -> . term MOD factor
    (39) term -> . STRLIT
    (40) term -> . factor
    (41) factor -> . INTLIT
    (42) factor -> . OPENPAR expression CLOSEPAR

    STRLIT          shift and go to state 13
    INTLIT          shift and go to state 6
    OPENPAR         shift and go to state 4

    term                           shift and go to state 59
    factor                         shift and go to state 12

state 36

    (29) boolean -> expression LEQ . term
    (36) term -> . term MUL factor
    (37) term -> . term DIV factor
    (38) term -> . term MOD factor
    (39) term -> . STRLIT
    (40) term -> . factor
    (41) factor -> . INTLIT
    (42) factor -> . OPENPAR expression CLOSEPAR

    STRLIT          shift and go to state 13
    INTLIT          shift and go to state 6
    OPENPAR         shift and go to state 4

    term                           shift and go to state 60
    factor                         shift and go to state 12

state 37

    (28) boolean -> expression LT . term
    (36) term -> . term MUL factor
    (37) term -> . term DIV factor
    (38) term -> . term MOD factor
    (39) term -> . STRLIT
    (40) term -> . factor
    (41) factor -> . INTLIT
    (42) factor -> . OPENPAR expression CLOSEPAR

    STRLIT          shift and go to state 13
    INTLIT          shift and go to state 6
    OPENPAR         shift and go to state 4

    term                           shift and go to state 61
    factor                         shift and go to state 12

state 38

    (34) expression -> expression PLUS . term
    (36) term -> . term MUL factor
    (37) term -> . term DIV factor
    (38) term -> . term MOD factor
    (39) term -> . STRLIT
    (40) term -> . factor
    (41) factor -> . INTLIT
    (42) factor -> . OPENPAR expression CLOSEPAR

    STRLIT          shift and go to state 13
    INTLIT          shift and go to state 6
    OPENPAR         shift and go to state 4

    term                           shift and go to state 62
    factor                         shift and go to state 12

state 39

    (8) statement -> expression TILDE .

    CLOSECURLY      reduce using rule 8 (statement -> expression TILDE .)
    VAR             reduce using rule 8 (statement -> expression TILDE .)
    def             reduce using rule 8 (statement -> expression TILDE .)
    class           reduce using rule 8 (statement -> expression TILDE .)
    print           reduce using rule 8 (statement -> expression TILDE .)
    if              reduce using rule 8 (statement -> expression TILDE .)
    STRLIT          reduce using rule 8 (statement -> expression TILDE .)
    INTLIT          reduce using rule 8 (statement -> expression TILDE .)
    OPENPAR         reduce using rule 8 (statement -> expression TILDE .)


state 40

    (35) expression -> expression MINUS . term
    (36) term -> . term MUL factor
    (37) term -> . term DIV factor
    (38) term -> . term MOD factor
    (39) term -> . STRLIT
    (40) term -> . factor
    (41) factor -> . INTLIT
    (42) factor -> . OPENPAR expression CLOSEPAR

    STRLIT          shift and go to state 13
    INTLIT          shift and go to state 6
    OPENPAR         shift and go to state 4

    term                           shift and go to state 63
    factor                         shift and go to state 12

state 41

    (31) boolean -> expression NEQ . term
    (36) term -> . term MUL factor
    (37) term -> . term DIV factor
    (38) term -> . term MOD factor
    (39) term -> . STRLIT
    (40) term -> . factor
    (41) factor -> . INTLIT
    (42) factor -> . OPENPAR expression CLOSEPAR

    STRLIT          shift and go to state 13
    INTLIT          shift and go to state 6
    OPENPAR         shift and go to state 4

    term                           shift and go to state 64
    factor                         shift and go to state 12

state 42

    (9) statement -> def VAR . OPENPAR parameter CLOSEPAR OPENCURLY statement CLOSECURLY end_def

    OPENPAR         shift and go to state 65


state 43

    (42) factor -> OPENPAR expression CLOSEPAR .

    MUL             reduce using rule 42 (factor -> OPENPAR expression CLOSEPAR .)
    DIV             reduce using rule 42 (factor -> OPENPAR expression CLOSEPAR .)
    MOD             reduce using rule 42 (factor -> OPENPAR expression CLOSEPAR .)
    TILDE           reduce using rule 42 (factor -> OPENPAR expression CLOSEPAR .)
    PLUS            reduce using rule 42 (factor -> OPENPAR expression CLOSEPAR .)
    MINUS           reduce using rule 42 (factor -> OPENPAR expression CLOSEPAR .)
    GT              reduce using rule 42 (factor -> OPENPAR expression CLOSEPAR .)
    GEQ             reduce using rule 42 (factor -> OPENPAR expression CLOSEPAR .)
    LT              reduce using rule 42 (factor -> OPENPAR expression CLOSEPAR .)
    LEQ             reduce using rule 42 (factor -> OPENPAR expression CLOSEPAR .)
    EQ              reduce using rule 42 (factor -> OPENPAR expression CLOSEPAR .)
    NEQ             reduce using rule 42 (factor -> OPENPAR expression CLOSEPAR .)
    AND             reduce using rule 42 (factor -> OPENPAR expression CLOSEPAR .)
    OR              reduce using rule 42 (factor -> OPENPAR expression CLOSEPAR .)
    CLOSEPAR        reduce using rule 42 (factor -> OPENPAR expression CLOSEPAR .)


state 44

    (22) if_statement -> if OPENPAR boolean . CLOSEPAR OPENCURLY statement CLOSECURLY
    (23) if_statement -> if OPENPAR boolean . CLOSEPAR OPENCURLY statement CLOSECURLY else OPENCURLY statement CLOSECURLY
    (25) expression -> boolean .

    CLOSEPAR        shift and go to state 66
    GT              reduce using rule 25 (expression -> boolean .)
    GEQ             reduce using rule 25 (expression -> boolean .)
    LT              reduce using rule 25 (expression -> boolean .)
    LEQ             reduce using rule 25 (expression -> boolean .)
    EQ              reduce using rule 25 (expression -> boolean .)
    NEQ             reduce using rule 25 (expression -> boolean .)
    AND             reduce using rule 25 (expression -> boolean .)
    OR              reduce using rule 25 (expression -> boolean .)
    PLUS            reduce using rule 25 (expression -> boolean .)
    MINUS           reduce using rule 25 (expression -> boolean .)


state 45

    (26) boolean -> expression . GT term
    (27) boolean -> expression . GEQ term
    (28) boolean -> expression . LT term
    (29) boolean -> expression . LEQ term
    (30) boolean -> expression . EQ term
    (31) boolean -> expression . NEQ term
    (32) boolean -> expression . AND term
    (33) boolean -> expression . OR term
    (34) expression -> expression . PLUS term
    (35) expression -> expression . MINUS term

    GT              shift and go to state 32
    GEQ             shift and go to state 34
    LT              shift and go to state 37
    LEQ             shift and go to state 36
    EQ              shift and go to state 33
    NEQ             shift and go to state 41
    AND             shift and go to state 31
    OR              shift and go to state 35
    PLUS            shift and go to state 38
    MINUS           shift and go to state 40


state 46

    (1) main_program -> start OPENCURLY statement CLOSECURLY end .

    $end            reduce using rule 1 (main_program -> start OPENCURLY statement CLOSECURLY end .)


state 47

    (18) statement -> print OPENPAR STRLIT . CLOSEPAR TILDE
    (39) term -> STRLIT .

  ! shift/reduce conflict for CLOSEPAR resolved as shift
    CLOSEPAR        shift and go to state 67
    MUL             reduce using rule 39 (term -> STRLIT .)
    DIV             reduce using rule 39 (term -> STRLIT .)
    MOD             reduce using rule 39 (term -> STRLIT .)
    PLUS            reduce using rule 39 (term -> STRLIT .)
    MINUS           reduce using rule 39 (term -> STRLIT .)
    GT              reduce using rule 39 (term -> STRLIT .)
    GEQ             reduce using rule 39 (term -> STRLIT .)
    LT              reduce using rule 39 (term -> STRLIT .)
    LEQ             reduce using rule 39 (term -> STRLIT .)
    EQ              reduce using rule 39 (term -> STRLIT .)
    NEQ             reduce using rule 39 (term -> STRLIT .)
    AND             reduce using rule 39 (term -> STRLIT .)
    OR              reduce using rule 39 (term -> STRLIT .)

  ! CLOSEPAR        [ reduce using rule 39 (term -> STRLIT .) ]


state 48

    (17) statement -> print OPENPAR expression . CLOSEPAR TILDE
    (34) expression -> expression . PLUS term
    (35) expression -> expression . MINUS term
    (26) boolean -> expression . GT term
    (27) boolean -> expression . GEQ term
    (28) boolean -> expression . LT term
    (29) boolean -> expression . LEQ term
    (30) boolean -> expression . EQ term
    (31) boolean -> expression . NEQ term
    (32) boolean -> expression . AND term
    (33) boolean -> expression . OR term

    CLOSEPAR        shift and go to state 68
    PLUS            shift and go to state 38
    MINUS           shift and go to state 40
    GT              shift and go to state 32
    GEQ             shift and go to state 34
    LT              shift and go to state 37
    LEQ             shift and go to state 36
    EQ              shift and go to state 33
    NEQ             shift and go to state 41
    AND             shift and go to state 31
    OR              shift and go to state 35


state 49

    (14) statement -> VAR ASSIGN STRLIT . TILDE scan OPENPAR VAR CLOSEPAR TILDE
    (16) statement -> VAR ASSIGN STRLIT . TILDE return OPENPAR VAR CLOSEPAR TILDE
    (20) statement -> VAR ASSIGN STRLIT . TILDE print OPENPAR VAR CLOSEPAR TILDE
    (39) term -> STRLIT .

  ! shift/reduce conflict for TILDE resolved as shift
    TILDE           shift and go to state 69
    MUL             reduce using rule 39 (term -> STRLIT .)
    DIV             reduce using rule 39 (term -> STRLIT .)
    MOD             reduce using rule 39 (term -> STRLIT .)
    PLUS            reduce using rule 39 (term -> STRLIT .)
    MINUS           reduce using rule 39 (term -> STRLIT .)
    GT              reduce using rule 39 (term -> STRLIT .)
    GEQ             reduce using rule 39 (term -> STRLIT .)
    LT              reduce using rule 39 (term -> STRLIT .)
    LEQ             reduce using rule 39 (term -> STRLIT .)
    EQ              reduce using rule 39 (term -> STRLIT .)
    NEQ             reduce using rule 39 (term -> STRLIT .)
    AND             reduce using rule 39 (term -> STRLIT .)
    OR              reduce using rule 39 (term -> STRLIT .)

  ! TILDE           [ reduce using rule 39 (term -> STRLIT .) ]


state 50

    (7) statement -> VAR ASSIGN expression . TILDE
    (13) statement -> VAR ASSIGN expression . TILDE scan OPENPAR VAR CLOSEPAR TILDE
    (15) statement -> VAR ASSIGN expression . TILDE return OPENPAR VAR CLOSEPAR TILDE
    (19) statement -> VAR ASSIGN expression . TILDE print OPENPAR VAR CLOSEPAR TILDE
    (34) expression -> expression . PLUS term
    (35) expression -> expression . MINUS term
    (26) boolean -> expression . GT term
    (27) boolean -> expression . GEQ term
    (28) boolean -> expression . LT term
    (29) boolean -> expression . LEQ term
    (30) boolean -> expression . EQ term
    (31) boolean -> expression . NEQ term
    (32) boolean -> expression . AND term
    (33) boolean -> expression . OR term

    TILDE           shift and go to state 70
    PLUS            shift and go to state 38
    MINUS           shift and go to state 40
    GT              shift and go to state 32
    GEQ             shift and go to state 34
    LT              shift and go to state 37
    LEQ             shift and go to state 36
    EQ              shift and go to state 33
    NEQ             shift and go to state 41
    AND             shift and go to state 31
    OR              shift and go to state 35


state 51

    (12) statement -> class VAR OPENCURLY . statement CLOSECURLY
    (2) statement -> . empty
    (4) statement -> . statement_list
    (7) statement -> . VAR ASSIGN expression TILDE
    (8) statement -> . expression TILDE
    (9) statement -> . def VAR OPENPAR parameter CLOSEPAR OPENCURLY statement CLOSECURLY end_def
    (12) statement -> . class VAR OPENCURLY statement CLOSECURLY
    (13) statement -> . VAR ASSIGN expression TILDE scan OPENPAR VAR CLOSEPAR TILDE
    (14) statement -> . VAR ASSIGN STRLIT TILDE scan OPENPAR VAR CLOSEPAR TILDE
    (15) statement -> . VAR ASSIGN expression TILDE return OPENPAR VAR CLOSEPAR TILDE
    (16) statement -> . VAR ASSIGN STRLIT TILDE return OPENPAR VAR CLOSEPAR TILDE
    (17) statement -> . print OPENPAR expression CLOSEPAR TILDE
    (18) statement -> . print OPENPAR STRLIT CLOSEPAR TILDE
    (19) statement -> . VAR ASSIGN expression TILDE print OPENPAR VAR CLOSEPAR TILDE
    (20) statement -> . VAR ASSIGN STRLIT TILDE print OPENPAR VAR CLOSEPAR TILDE
    (21) statement -> . if_statement
    (3) empty -> .
    (5) statement_list -> . statement
    (6) statement_list -> . statement statement_list
    (24) expression -> . term
    (25) expression -> . boolean
    (34) expression -> . expression PLUS term
    (35) expression -> . expression MINUS term
    (22) if_statement -> . if OPENPAR boolean CLOSEPAR OPENCURLY statement CLOSECURLY
    (23) if_statement -> . if OPENPAR boolean CLOSEPAR OPENCURLY statement CLOSECURLY else OPENCURLY statement CLOSECURLY
    (36) term -> . term MUL factor
    (37) term -> . term DIV factor
    (38) term -> . term MOD factor
    (39) term -> . STRLIT
    (40) term -> . factor
    (26) boolean -> . expression GT term
    (27) boolean -> . expression GEQ term
    (28) boolean -> . expression LT term
    (29) boolean -> . expression LEQ term
    (30) boolean -> . expression EQ term
    (31) boolean -> . expression NEQ term
    (32) boolean -> . expression AND term
    (33) boolean -> . expression OR term
    (41) factor -> . INTLIT
    (42) factor -> . OPENPAR expression CLOSEPAR

  ! shift/reduce conflict for VAR resolved as shift
  ! shift/reduce conflict for def resolved as shift
  ! shift/reduce conflict for class resolved as shift
  ! shift/reduce conflict for print resolved as shift
  ! shift/reduce conflict for if resolved as shift
  ! shift/reduce conflict for STRLIT resolved as shift
  ! shift/reduce conflict for INTLIT resolved as shift
  ! shift/reduce conflict for OPENPAR resolved as shift
    VAR             shift and go to state 14
    def             shift and go to state 19
    class           shift and go to state 15
    print           shift and go to state 9
    CLOSECURLY      reduce using rule 3 (empty -> .)
    if              shift and go to state 7
    STRLIT          shift and go to state 13
    INTLIT          shift and go to state 6
    OPENPAR         shift and go to state 4

  ! VAR             [ reduce using rule 3 (empty -> .) ]
  ! def             [ reduce using rule 3 (empty -> .) ]
  ! class           [ reduce using rule 3 (empty -> .) ]
  ! print           [ reduce using rule 3 (empty -> .) ]
  ! if              [ reduce using rule 3 (empty -> .) ]
  ! STRLIT          [ reduce using rule 3 (empty -> .) ]
  ! INTLIT          [ reduce using rule 3 (empty -> .) ]
  ! OPENPAR         [ reduce using rule 3 (empty -> .) ]

    term                           shift and go to state 16
    expression                     shift and go to state 18
    boolean                        shift and go to state 5
    statement                      shift and go to state 71
    factor                         shift and go to state 12
    statement_list                 shift and go to state 17
    if_statement                   shift and go to state 10
    empty                          shift and go to state 11

state 52

    (36) term -> term MUL factor .

    MUL             reduce using rule 36 (term -> term MUL factor .)
    DIV             reduce using rule 36 (term -> term MUL factor .)
    MOD             reduce using rule 36 (term -> term MUL factor .)
    TILDE           reduce using rule 36 (term -> term MUL factor .)
    PLUS            reduce using rule 36 (term -> term MUL factor .)
    MINUS           reduce using rule 36 (term -> term MUL factor .)
    GT              reduce using rule 36 (term -> term MUL factor .)
    GEQ             reduce using rule 36 (term -> term MUL factor .)
    LT              reduce using rule 36 (term -> term MUL factor .)
    LEQ             reduce using rule 36 (term -> term MUL factor .)
    EQ              reduce using rule 36 (term -> term MUL factor .)
    NEQ             reduce using rule 36 (term -> term MUL factor .)
    AND             reduce using rule 36 (term -> term MUL factor .)
    OR              reduce using rule 36 (term -> term MUL factor .)
    CLOSEPAR        reduce using rule 36 (term -> term MUL factor .)


state 53

    (38) term -> term MOD factor .

    MUL             reduce using rule 38 (term -> term MOD factor .)
    DIV             reduce using rule 38 (term -> term MOD factor .)
    MOD             reduce using rule 38 (term -> term MOD factor .)
    TILDE           reduce using rule 38 (term -> term MOD factor .)
    PLUS            reduce using rule 38 (term -> term MOD factor .)
    MINUS           reduce using rule 38 (term -> term MOD factor .)
    GT              reduce using rule 38 (term -> term MOD factor .)
    GEQ             reduce using rule 38 (term -> term MOD factor .)
    LT              reduce using rule 38 (term -> term MOD factor .)
    LEQ             reduce using rule 38 (term -> term MOD factor .)
    EQ              reduce using rule 38 (term -> term MOD factor .)
    NEQ             reduce using rule 38 (term -> term MOD factor .)
    AND             reduce using rule 38 (term -> term MOD factor .)
    OR              reduce using rule 38 (term -> term MOD factor .)
    CLOSEPAR        reduce using rule 38 (term -> term MOD factor .)


state 54

    (37) term -> term DIV factor .

    MUL             reduce using rule 37 (term -> term DIV factor .)
    DIV             reduce using rule 37 (term -> term DIV factor .)
    MOD             reduce using rule 37 (term -> term DIV factor .)
    TILDE           reduce using rule 37 (term -> term DIV factor .)
    PLUS            reduce using rule 37 (term -> term DIV factor .)
    MINUS           reduce using rule 37 (term -> term DIV factor .)
    GT              reduce using rule 37 (term -> term DIV factor .)
    GEQ             reduce using rule 37 (term -> term DIV factor .)
    LT              reduce using rule 37 (term -> term DIV factor .)
    LEQ             reduce using rule 37 (term -> term DIV factor .)
    EQ              reduce using rule 37 (term -> term DIV factor .)
    NEQ             reduce using rule 37 (term -> term DIV factor .)
    AND             reduce using rule 37 (term -> term DIV factor .)
    OR              reduce using rule 37 (term -> term DIV factor .)
    CLOSEPAR        reduce using rule 37 (term -> term DIV factor .)


state 55

    (32) boolean -> expression AND term .
    (36) term -> term . MUL factor
    (37) term -> term . DIV factor
    (38) term -> term . MOD factor

    TILDE           reduce using rule 32 (boolean -> expression AND term .)
    PLUS            reduce using rule 32 (boolean -> expression AND term .)
    MINUS           reduce using rule 32 (boolean -> expression AND term .)
    GT              reduce using rule 32 (boolean -> expression AND term .)
    GEQ             reduce using rule 32 (boolean -> expression AND term .)
    LT              reduce using rule 32 (boolean -> expression AND term .)
    LEQ             reduce using rule 32 (boolean -> expression AND term .)
    EQ              reduce using rule 32 (boolean -> expression AND term .)
    NEQ             reduce using rule 32 (boolean -> expression AND term .)
    AND             reduce using rule 32 (boolean -> expression AND term .)
    OR              reduce using rule 32 (boolean -> expression AND term .)
    CLOSEPAR        reduce using rule 32 (boolean -> expression AND term .)
    MUL             shift and go to state 28
    DIV             shift and go to state 30
    MOD             shift and go to state 29


state 56

    (26) boolean -> expression GT term .
    (36) term -> term . MUL factor
    (37) term -> term . DIV factor
    (38) term -> term . MOD factor

    TILDE           reduce using rule 26 (boolean -> expression GT term .)
    PLUS            reduce using rule 26 (boolean -> expression GT term .)
    MINUS           reduce using rule 26 (boolean -> expression GT term .)
    GT              reduce using rule 26 (boolean -> expression GT term .)
    GEQ             reduce using rule 26 (boolean -> expression GT term .)
    LT              reduce using rule 26 (boolean -> expression GT term .)
    LEQ             reduce using rule 26 (boolean -> expression GT term .)
    EQ              reduce using rule 26 (boolean -> expression GT term .)
    NEQ             reduce using rule 26 (boolean -> expression GT term .)
    AND             reduce using rule 26 (boolean -> expression GT term .)
    OR              reduce using rule 26 (boolean -> expression GT term .)
    CLOSEPAR        reduce using rule 26 (boolean -> expression GT term .)
    MUL             shift and go to state 28
    DIV             shift and go to state 30
    MOD             shift and go to state 29


state 57

    (30) boolean -> expression EQ term .
    (36) term -> term . MUL factor
    (37) term -> term . DIV factor
    (38) term -> term . MOD factor

    TILDE           reduce using rule 30 (boolean -> expression EQ term .)
    PLUS            reduce using rule 30 (boolean -> expression EQ term .)
    MINUS           reduce using rule 30 (boolean -> expression EQ term .)
    GT              reduce using rule 30 (boolean -> expression EQ term .)
    GEQ             reduce using rule 30 (boolean -> expression EQ term .)
    LT              reduce using rule 30 (boolean -> expression EQ term .)
    LEQ             reduce using rule 30 (boolean -> expression EQ term .)
    EQ              reduce using rule 30 (boolean -> expression EQ term .)
    NEQ             reduce using rule 30 (boolean -> expression EQ term .)
    AND             reduce using rule 30 (boolean -> expression EQ term .)
    OR              reduce using rule 30 (boolean -> expression EQ term .)
    CLOSEPAR        reduce using rule 30 (boolean -> expression EQ term .)
    MUL             shift and go to state 28
    DIV             shift and go to state 30
    MOD             shift and go to state 29


state 58

    (27) boolean -> expression GEQ term .
    (36) term -> term . MUL factor
    (37) term -> term . DIV factor
    (38) term -> term . MOD factor

    TILDE           reduce using rule 27 (boolean -> expression GEQ term .)
    PLUS            reduce using rule 27 (boolean -> expression GEQ term .)
    MINUS           reduce using rule 27 (boolean -> expression GEQ term .)
    GT              reduce using rule 27 (boolean -> expression GEQ term .)
    GEQ             reduce using rule 27 (boolean -> expression GEQ term .)
    LT              reduce using rule 27 (boolean -> expression GEQ term .)
    LEQ             reduce using rule 27 (boolean -> expression GEQ term .)
    EQ              reduce using rule 27 (boolean -> expression GEQ term .)
    NEQ             reduce using rule 27 (boolean -> expression GEQ term .)
    AND             reduce using rule 27 (boolean -> expression GEQ term .)
    OR              reduce using rule 27 (boolean -> expression GEQ term .)
    CLOSEPAR        reduce using rule 27 (boolean -> expression GEQ term .)
    MUL             shift and go to state 28
    DIV             shift and go to state 30
    MOD             shift and go to state 29


state 59

    (33) boolean -> expression OR term .
    (36) term -> term . MUL factor
    (37) term -> term . DIV factor
    (38) term -> term . MOD factor

    TILDE           reduce using rule 33 (boolean -> expression OR term .)
    PLUS            reduce using rule 33 (boolean -> expression OR term .)
    MINUS           reduce using rule 33 (boolean -> expression OR term .)
    GT              reduce using rule 33 (boolean -> expression OR term .)
    GEQ             reduce using rule 33 (boolean -> expression OR term .)
    LT              reduce using rule 33 (boolean -> expression OR term .)
    LEQ             reduce using rule 33 (boolean -> expression OR term .)
    EQ              reduce using rule 33 (boolean -> expression OR term .)
    NEQ             reduce using rule 33 (boolean -> expression OR term .)
    AND             reduce using rule 33 (boolean -> expression OR term .)
    OR              reduce using rule 33 (boolean -> expression OR term .)
    CLOSEPAR        reduce using rule 33 (boolean -> expression OR term .)
    MUL             shift and go to state 28
    DIV             shift and go to state 30
    MOD             shift and go to state 29


state 60

    (29) boolean -> expression LEQ term .
    (36) term -> term . MUL factor
    (37) term -> term . DIV factor
    (38) term -> term . MOD factor

    TILDE           reduce using rule 29 (boolean -> expression LEQ term .)
    PLUS            reduce using rule 29 (boolean -> expression LEQ term .)
    MINUS           reduce using rule 29 (boolean -> expression LEQ term .)
    GT              reduce using rule 29 (boolean -> expression LEQ term .)
    GEQ             reduce using rule 29 (boolean -> expression LEQ term .)
    LT              reduce using rule 29 (boolean -> expression LEQ term .)
    LEQ             reduce using rule 29 (boolean -> expression LEQ term .)
    EQ              reduce using rule 29 (boolean -> expression LEQ term .)
    NEQ             reduce using rule 29 (boolean -> expression LEQ term .)
    AND             reduce using rule 29 (boolean -> expression LEQ term .)
    OR              reduce using rule 29 (boolean -> expression LEQ term .)
    CLOSEPAR        reduce using rule 29 (boolean -> expression LEQ term .)
    MUL             shift and go to state 28
    DIV             shift and go to state 30
    MOD             shift and go to state 29


state 61

    (28) boolean -> expression LT term .
    (36) term -> term . MUL factor
    (37) term -> term . DIV factor
    (38) term -> term . MOD factor

    TILDE           reduce using rule 28 (boolean -> expression LT term .)
    PLUS            reduce using rule 28 (boolean -> expression LT term .)
    MINUS           reduce using rule 28 (boolean -> expression LT term .)
    GT              reduce using rule 28 (boolean -> expression LT term .)
    GEQ             reduce using rule 28 (boolean -> expression LT term .)
    LT              reduce using rule 28 (boolean -> expression LT term .)
    LEQ             reduce using rule 28 (boolean -> expression LT term .)
    EQ              reduce using rule 28 (boolean -> expression LT term .)
    NEQ             reduce using rule 28 (boolean -> expression LT term .)
    AND             reduce using rule 28 (boolean -> expression LT term .)
    OR              reduce using rule 28 (boolean -> expression LT term .)
    CLOSEPAR        reduce using rule 28 (boolean -> expression LT term .)
    MUL             shift and go to state 28
    DIV             shift and go to state 30
    MOD             shift and go to state 29


state 62

    (34) expression -> expression PLUS term .
    (36) term -> term . MUL factor
    (37) term -> term . DIV factor
    (38) term -> term . MOD factor

    TILDE           reduce using rule 34 (expression -> expression PLUS term .)
    PLUS            reduce using rule 34 (expression -> expression PLUS term .)
    MINUS           reduce using rule 34 (expression -> expression PLUS term .)
    GT              reduce using rule 34 (expression -> expression PLUS term .)
    GEQ             reduce using rule 34 (expression -> expression PLUS term .)
    LT              reduce using rule 34 (expression -> expression PLUS term .)
    LEQ             reduce using rule 34 (expression -> expression PLUS term .)
    EQ              reduce using rule 34 (expression -> expression PLUS term .)
    NEQ             reduce using rule 34 (expression -> expression PLUS term .)
    AND             reduce using rule 34 (expression -> expression PLUS term .)
    OR              reduce using rule 34 (expression -> expression PLUS term .)
    CLOSEPAR        reduce using rule 34 (expression -> expression PLUS term .)
    MUL             shift and go to state 28
    DIV             shift and go to state 30
    MOD             shift and go to state 29


state 63

    (35) expression -> expression MINUS term .
    (36) term -> term . MUL factor
    (37) term -> term . DIV factor
    (38) term -> term . MOD factor

    TILDE           reduce using rule 35 (expression -> expression MINUS term .)
    PLUS            reduce using rule 35 (expression -> expression MINUS term .)
    MINUS           reduce using rule 35 (expression -> expression MINUS term .)
    GT              reduce using rule 35 (expression -> expression MINUS term .)
    GEQ             reduce using rule 35 (expression -> expression MINUS term .)
    LT              reduce using rule 35 (expression -> expression MINUS term .)
    LEQ             reduce using rule 35 (expression -> expression MINUS term .)
    EQ              reduce using rule 35 (expression -> expression MINUS term .)
    NEQ             reduce using rule 35 (expression -> expression MINUS term .)
    AND             reduce using rule 35 (expression -> expression MINUS term .)
    OR              reduce using rule 35 (expression -> expression MINUS term .)
    CLOSEPAR        reduce using rule 35 (expression -> expression MINUS term .)
    MUL             shift and go to state 28
    DIV             shift and go to state 30
    MOD             shift and go to state 29


state 64

    (31) boolean -> expression NEQ term .
    (36) term -> term . MUL factor
    (37) term -> term . DIV factor
    (38) term -> term . MOD factor

    TILDE           reduce using rule 31 (boolean -> expression NEQ term .)
    PLUS            reduce using rule 31 (boolean -> expression NEQ term .)
    MINUS           reduce using rule 31 (boolean -> expression NEQ term .)
    GT              reduce using rule 31 (boolean -> expression NEQ term .)
    GEQ             reduce using rule 31 (boolean -> expression NEQ term .)
    LT              reduce using rule 31 (boolean -> expression NEQ term .)
    LEQ             reduce using rule 31 (boolean -> expression NEQ term .)
    EQ              reduce using rule 31 (boolean -> expression NEQ term .)
    NEQ             reduce using rule 31 (boolean -> expression NEQ term .)
    AND             reduce using rule 31 (boolean -> expression NEQ term .)
    OR              reduce using rule 31 (boolean -> expression NEQ term .)
    CLOSEPAR        reduce using rule 31 (boolean -> expression NEQ term .)
    MUL             shift and go to state 28
    DIV             shift and go to state 30
    MOD             shift and go to state 29


state 65

    (9) statement -> def VAR OPENPAR . parameter CLOSEPAR OPENCURLY statement CLOSECURLY end_def
    (10) parameter -> . int VAR
    (11) parameter -> . string VAR

    int             shift and go to state 73
    string          shift and go to state 72

    parameter                      shift and go to state 74

state 66

    (22) if_statement -> if OPENPAR boolean CLOSEPAR . OPENCURLY statement CLOSECURLY
    (23) if_statement -> if OPENPAR boolean CLOSEPAR . OPENCURLY statement CLOSECURLY else OPENCURLY statement CLOSECURLY

    OPENCURLY       shift and go to state 75


state 67

    (18) statement -> print OPENPAR STRLIT CLOSEPAR . TILDE

    TILDE           shift and go to state 76


state 68

    (17) statement -> print OPENPAR expression CLOSEPAR . TILDE

    TILDE           shift and go to state 77


state 69

    (14) statement -> VAR ASSIGN STRLIT TILDE . scan OPENPAR VAR CLOSEPAR TILDE
    (16) statement -> VAR ASSIGN STRLIT TILDE . return OPENPAR VAR CLOSEPAR TILDE
    (20) statement -> VAR ASSIGN STRLIT TILDE . print OPENPAR VAR CLOSEPAR TILDE

    scan            shift and go to state 79
    return          shift and go to state 78
    print           shift and go to state 80


state 70

    (7) statement -> VAR ASSIGN expression TILDE .
    (13) statement -> VAR ASSIGN expression TILDE . scan OPENPAR VAR CLOSEPAR TILDE
    (15) statement -> VAR ASSIGN expression TILDE . return OPENPAR VAR CLOSEPAR TILDE
    (19) statement -> VAR ASSIGN expression TILDE . print OPENPAR VAR CLOSEPAR TILDE

  ! shift/reduce conflict for print resolved as shift
    CLOSECURLY      reduce using rule 7 (statement -> VAR ASSIGN expression TILDE .)
    VAR             reduce using rule 7 (statement -> VAR ASSIGN expression TILDE .)
    def             reduce using rule 7 (statement -> VAR ASSIGN expression TILDE .)
    class           reduce using rule 7 (statement -> VAR ASSIGN expression TILDE .)
    if              reduce using rule 7 (statement -> VAR ASSIGN expression TILDE .)
    STRLIT          reduce using rule 7 (statement -> VAR ASSIGN expression TILDE .)
    INTLIT          reduce using rule 7 (statement -> VAR ASSIGN expression TILDE .)
    OPENPAR         reduce using rule 7 (statement -> VAR ASSIGN expression TILDE .)
    scan            shift and go to state 82
    return          shift and go to state 81
    print           shift and go to state 83

  ! print           [ reduce using rule 7 (statement -> VAR ASSIGN expression TILDE .) ]


state 71

    (12) statement -> class VAR OPENCURLY statement . CLOSECURLY
    (5) statement_list -> statement .
    (6) statement_list -> statement . statement_list
    (5) statement_list -> . statement
    (6) statement_list -> . statement statement_list
    (2) statement -> . empty
    (4) statement -> . statement_list
    (7) statement -> . VAR ASSIGN expression TILDE
    (8) statement -> . expression TILDE
    (9) statement -> . def VAR OPENPAR parameter CLOSEPAR OPENCURLY statement CLOSECURLY end_def
    (12) statement -> . class VAR OPENCURLY statement CLOSECURLY
    (13) statement -> . VAR ASSIGN expression TILDE scan OPENPAR VAR CLOSEPAR TILDE
    (14) statement -> . VAR ASSIGN STRLIT TILDE scan OPENPAR VAR CLOSEPAR TILDE
    (15) statement -> . VAR ASSIGN expression TILDE return OPENPAR VAR CLOSEPAR TILDE
    (16) statement -> . VAR ASSIGN STRLIT TILDE return OPENPAR VAR CLOSEPAR TILDE
    (17) statement -> . print OPENPAR expression CLOSEPAR TILDE
    (18) statement -> . print OPENPAR STRLIT CLOSEPAR TILDE
    (19) statement -> . VAR ASSIGN expression TILDE print OPENPAR VAR CLOSEPAR TILDE
    (20) statement -> . VAR ASSIGN STRLIT TILDE print OPENPAR VAR CLOSEPAR TILDE
    (21) statement -> . if_statement
    (3) empty -> .
    (24) expression -> . term
    (25) expression -> . boolean
    (34) expression -> . expression PLUS term
    (35) expression -> . expression MINUS term
    (22) if_statement -> . if OPENPAR boolean CLOSEPAR OPENCURLY statement CLOSECURLY
    (23) if_statement -> . if OPENPAR boolean CLOSEPAR OPENCURLY statement CLOSECURLY else OPENCURLY statement CLOSECURLY
    (36) term -> . term MUL factor
    (37) term -> . term DIV factor
    (38) term -> . term MOD factor
    (39) term -> . STRLIT
    (40) term -> . factor
    (26) boolean -> . expression GT term
    (27) boolean -> . expression GEQ term
    (28) boolean -> . expression LT term
    (29) boolean -> . expression LEQ term
    (30) boolean -> . expression EQ term
    (31) boolean -> . expression NEQ term
    (32) boolean -> . expression AND term
    (33) boolean -> . expression OR term
    (41) factor -> . INTLIT
    (42) factor -> . OPENPAR expression CLOSEPAR

  ! shift/reduce conflict for CLOSECURLY resolved as shift
  ! shift/reduce conflict for VAR resolved as shift
  ! shift/reduce conflict for def resolved as shift
  ! shift/reduce conflict for class resolved as shift
  ! shift/reduce conflict for print resolved as shift
  ! shift/reduce conflict for CLOSECURLY resolved as shift
  ! shift/reduce conflict for VAR resolved as shift
  ! shift/reduce conflict for def resolved as shift
  ! shift/reduce conflict for class resolved as shift
  ! shift/reduce conflict for print resolved as shift
  ! reduce/reduce conflict for if resolved using rule 3 (empty -> .)
  ! reduce/reduce conflict for STRLIT resolved using rule 3 (empty -> .)
  ! reduce/reduce conflict for INTLIT resolved using rule 3 (empty -> .)
  ! reduce/reduce conflict for OPENPAR resolved using rule 3 (empty -> .)
  ! shift/reduce conflict for if resolved as shift
  ! shift/reduce conflict for STRLIT resolved as shift
  ! shift/reduce conflict for INTLIT resolved as shift
  ! shift/reduce conflict for OPENPAR resolved as shift
    CLOSECURLY      shift and go to state 84
    VAR             shift and go to state 14
    def             shift and go to state 19
    class           shift and go to state 15
    print           shift and go to state 9
    if              shift and go to state 7
    STRLIT          shift and go to state 13
    INTLIT          shift and go to state 6
    OPENPAR         shift and go to state 4

  ! CLOSECURLY      [ reduce using rule 5 (statement_list -> statement .) ]
  ! VAR             [ reduce using rule 5 (statement_list -> statement .) ]
  ! def             [ reduce using rule 5 (statement_list -> statement .) ]
  ! class           [ reduce using rule 5 (statement_list -> statement .) ]
  ! print           [ reduce using rule 5 (statement_list -> statement .) ]
  ! if              [ reduce using rule 5 (statement_list -> statement .) ]
  ! STRLIT          [ reduce using rule 5 (statement_list -> statement .) ]
  ! INTLIT          [ reduce using rule 5 (statement_list -> statement .) ]
  ! OPENPAR         [ reduce using rule 5 (statement_list -> statement .) ]
  ! CLOSECURLY      [ reduce using rule 3 (empty -> .) ]
  ! VAR             [ reduce using rule 3 (empty -> .) ]
  ! def             [ reduce using rule 3 (empty -> .) ]
  ! class           [ reduce using rule 3 (empty -> .) ]
  ! print           [ reduce using rule 3 (empty -> .) ]
  ! if              [ reduce using rule 3 (empty -> .) ]
  ! STRLIT          [ reduce using rule 3 (empty -> .) ]
  ! INTLIT          [ reduce using rule 3 (empty -> .) ]
  ! OPENPAR         [ reduce using rule 3 (empty -> .) ]

    term                           shift and go to state 16
    expression                     shift and go to state 18
    boolean                        shift and go to state 5
    statement                      shift and go to state 23
    factor                         shift and go to state 12
    statement_list                 shift and go to state 24
    if_statement                   shift and go to state 10
    empty                          shift and go to state 11

state 72

    (11) parameter -> string . VAR

    VAR             shift and go to state 85


state 73

    (10) parameter -> int . VAR

    VAR             shift and go to state 86


state 74

    (9) statement -> def VAR OPENPAR parameter . CLOSEPAR OPENCURLY statement CLOSECURLY end_def

    CLOSEPAR        shift and go to state 87


state 75

    (22) if_statement -> if OPENPAR boolean CLOSEPAR OPENCURLY . statement CLOSECURLY
    (23) if_statement -> if OPENPAR boolean CLOSEPAR OPENCURLY . statement CLOSECURLY else OPENCURLY statement CLOSECURLY
    (2) statement -> . empty
    (4) statement -> . statement_list
    (7) statement -> . VAR ASSIGN expression TILDE
    (8) statement -> . expression TILDE
    (9) statement -> . def VAR OPENPAR parameter CLOSEPAR OPENCURLY statement CLOSECURLY end_def
    (12) statement -> . class VAR OPENCURLY statement CLOSECURLY
    (13) statement -> . VAR ASSIGN expression TILDE scan OPENPAR VAR CLOSEPAR TILDE
    (14) statement -> . VAR ASSIGN STRLIT TILDE scan OPENPAR VAR CLOSEPAR TILDE
    (15) statement -> . VAR ASSIGN expression TILDE return OPENPAR VAR CLOSEPAR TILDE
    (16) statement -> . VAR ASSIGN STRLIT TILDE return OPENPAR VAR CLOSEPAR TILDE
    (17) statement -> . print OPENPAR expression CLOSEPAR TILDE
    (18) statement -> . print OPENPAR STRLIT CLOSEPAR TILDE
    (19) statement -> . VAR ASSIGN expression TILDE print OPENPAR VAR CLOSEPAR TILDE
    (20) statement -> . VAR ASSIGN STRLIT TILDE print OPENPAR VAR CLOSEPAR TILDE
    (21) statement -> . if_statement
    (3) empty -> .
    (5) statement_list -> . statement
    (6) statement_list -> . statement statement_list
    (24) expression -> . term
    (25) expression -> . boolean
    (34) expression -> . expression PLUS term
    (35) expression -> . expression MINUS term
    (22) if_statement -> . if OPENPAR boolean CLOSEPAR OPENCURLY statement CLOSECURLY
    (23) if_statement -> . if OPENPAR boolean CLOSEPAR OPENCURLY statement CLOSECURLY else OPENCURLY statement CLOSECURLY
    (36) term -> . term MUL factor
    (37) term -> . term DIV factor
    (38) term -> . term MOD factor
    (39) term -> . STRLIT
    (40) term -> . factor
    (26) boolean -> . expression GT term
    (27) boolean -> . expression GEQ term
    (28) boolean -> . expression LT term
    (29) boolean -> . expression LEQ term
    (30) boolean -> . expression EQ term
    (31) boolean -> . expression NEQ term
    (32) boolean -> . expression AND term
    (33) boolean -> . expression OR term
    (41) factor -> . INTLIT
    (42) factor -> . OPENPAR expression CLOSEPAR

  ! shift/reduce conflict for VAR resolved as shift
  ! shift/reduce conflict for def resolved as shift
  ! shift/reduce conflict for class resolved as shift
  ! shift/reduce conflict for print resolved as shift
  ! shift/reduce conflict for if resolved as shift
  ! shift/reduce conflict for STRLIT resolved as shift
  ! shift/reduce conflict for INTLIT resolved as shift
  ! shift/reduce conflict for OPENPAR resolved as shift
    VAR             shift and go to state 14
    def             shift and go to state 19
    class           shift and go to state 15
    print           shift and go to state 9
    CLOSECURLY      reduce using rule 3 (empty -> .)
    if              shift and go to state 7
    STRLIT          shift and go to state 13
    INTLIT          shift and go to state 6
    OPENPAR         shift and go to state 4

  ! VAR             [ reduce using rule 3 (empty -> .) ]
  ! def             [ reduce using rule 3 (empty -> .) ]
  ! class           [ reduce using rule 3 (empty -> .) ]
  ! print           [ reduce using rule 3 (empty -> .) ]
  ! if              [ reduce using rule 3 (empty -> .) ]
  ! STRLIT          [ reduce using rule 3 (empty -> .) ]
  ! INTLIT          [ reduce using rule 3 (empty -> .) ]
  ! OPENPAR         [ reduce using rule 3 (empty -> .) ]

    term                           shift and go to state 16
    expression                     shift and go to state 18
    boolean                        shift and go to state 5
    statement                      shift and go to state 88
    factor                         shift and go to state 12
    statement_list                 shift and go to state 17
    if_statement                   shift and go to state 10
    empty                          shift and go to state 11

state 76

    (18) statement -> print OPENPAR STRLIT CLOSEPAR TILDE .

    CLOSECURLY      reduce using rule 18 (statement -> print OPENPAR STRLIT CLOSEPAR TILDE .)
    VAR             reduce using rule 18 (statement -> print OPENPAR STRLIT CLOSEPAR TILDE .)
    def             reduce using rule 18 (statement -> print OPENPAR STRLIT CLOSEPAR TILDE .)
    class           reduce using rule 18 (statement -> print OPENPAR STRLIT CLOSEPAR TILDE .)
    print           reduce using rule 18 (statement -> print OPENPAR STRLIT CLOSEPAR TILDE .)
    if              reduce using rule 18 (statement -> print OPENPAR STRLIT CLOSEPAR TILDE .)
    STRLIT          reduce using rule 18 (statement -> print OPENPAR STRLIT CLOSEPAR TILDE .)
    INTLIT          reduce using rule 18 (statement -> print OPENPAR STRLIT CLOSEPAR TILDE .)
    OPENPAR         reduce using rule 18 (statement -> print OPENPAR STRLIT CLOSEPAR TILDE .)


state 77

    (17) statement -> print OPENPAR expression CLOSEPAR TILDE .

    CLOSECURLY      reduce using rule 17 (statement -> print OPENPAR expression CLOSEPAR TILDE .)
    VAR             reduce using rule 17 (statement -> print OPENPAR expression CLOSEPAR TILDE .)
    def             reduce using rule 17 (statement -> print OPENPAR expression CLOSEPAR TILDE .)
    class           reduce using rule 17 (statement -> print OPENPAR expression CLOSEPAR TILDE .)
    print           reduce using rule 17 (statement -> print OPENPAR expression CLOSEPAR TILDE .)
    if              reduce using rule 17 (statement -> print OPENPAR expression CLOSEPAR TILDE .)
    STRLIT          reduce using rule 17 (statement -> print OPENPAR expression CLOSEPAR TILDE .)
    INTLIT          reduce using rule 17 (statement -> print OPENPAR expression CLOSEPAR TILDE .)
    OPENPAR         reduce using rule 17 (statement -> print OPENPAR expression CLOSEPAR TILDE .)


state 78

    (16) statement -> VAR ASSIGN STRLIT TILDE return . OPENPAR VAR CLOSEPAR TILDE

    OPENPAR         shift and go to state 89


state 79

    (14) statement -> VAR ASSIGN STRLIT TILDE scan . OPENPAR VAR CLOSEPAR TILDE

    OPENPAR         shift and go to state 90


state 80

    (20) statement -> VAR ASSIGN STRLIT TILDE print . OPENPAR VAR CLOSEPAR TILDE

    OPENPAR         shift and go to state 91


state 81

    (15) statement -> VAR ASSIGN expression TILDE return . OPENPAR VAR CLOSEPAR TILDE

    OPENPAR         shift and go to state 92


state 82

    (13) statement -> VAR ASSIGN expression TILDE scan . OPENPAR VAR CLOSEPAR TILDE

    OPENPAR         shift and go to state 93


state 83

    (19) statement -> VAR ASSIGN expression TILDE print . OPENPAR VAR CLOSEPAR TILDE

    OPENPAR         shift and go to state 94


state 84

    (12) statement -> class VAR OPENCURLY statement CLOSECURLY .

    CLOSECURLY      reduce using rule 12 (statement -> class VAR OPENCURLY statement CLOSECURLY .)
    VAR             reduce using rule 12 (statement -> class VAR OPENCURLY statement CLOSECURLY .)
    def             reduce using rule 12 (statement -> class VAR OPENCURLY statement CLOSECURLY .)
    class           reduce using rule 12 (statement -> class VAR OPENCURLY statement CLOSECURLY .)
    print           reduce using rule 12 (statement -> class VAR OPENCURLY statement CLOSECURLY .)
    if              reduce using rule 12 (statement -> class VAR OPENCURLY statement CLOSECURLY .)
    STRLIT          reduce using rule 12 (statement -> class VAR OPENCURLY statement CLOSECURLY .)
    INTLIT          reduce using rule 12 (statement -> class VAR OPENCURLY statement CLOSECURLY .)
    OPENPAR         reduce using rule 12 (statement -> class VAR OPENCURLY statement CLOSECURLY .)


state 85

    (11) parameter -> string VAR .

    CLOSEPAR        reduce using rule 11 (parameter -> string VAR .)


state 86

    (10) parameter -> int VAR .

    CLOSEPAR        reduce using rule 10 (parameter -> int VAR .)


state 87

    (9) statement -> def VAR OPENPAR parameter CLOSEPAR . OPENCURLY statement CLOSECURLY end_def

    OPENCURLY       shift and go to state 95


state 88

    (22) if_statement -> if OPENPAR boolean CLOSEPAR OPENCURLY statement . CLOSECURLY
    (23) if_statement -> if OPENPAR boolean CLOSEPAR OPENCURLY statement . CLOSECURLY else OPENCURLY statement CLOSECURLY
    (5) statement_list -> statement .
    (6) statement_list -> statement . statement_list
    (5) statement_list -> . statement
    (6) statement_list -> . statement statement_list
    (2) statement -> . empty
    (4) statement -> . statement_list
    (7) statement -> . VAR ASSIGN expression TILDE
    (8) statement -> . expression TILDE
    (9) statement -> . def VAR OPENPAR parameter CLOSEPAR OPENCURLY statement CLOSECURLY end_def
    (12) statement -> . class VAR OPENCURLY statement CLOSECURLY
    (13) statement -> . VAR ASSIGN expression TILDE scan OPENPAR VAR CLOSEPAR TILDE
    (14) statement -> . VAR ASSIGN STRLIT TILDE scan OPENPAR VAR CLOSEPAR TILDE
    (15) statement -> . VAR ASSIGN expression TILDE return OPENPAR VAR CLOSEPAR TILDE
    (16) statement -> . VAR ASSIGN STRLIT TILDE return OPENPAR VAR CLOSEPAR TILDE
    (17) statement -> . print OPENPAR expression CLOSEPAR TILDE
    (18) statement -> . print OPENPAR STRLIT CLOSEPAR TILDE
    (19) statement -> . VAR ASSIGN expression TILDE print OPENPAR VAR CLOSEPAR TILDE
    (20) statement -> . VAR ASSIGN STRLIT TILDE print OPENPAR VAR CLOSEPAR TILDE
    (21) statement -> . if_statement
    (3) empty -> .
    (24) expression -> . term
    (25) expression -> . boolean
    (34) expression -> . expression PLUS term
    (35) expression -> . expression MINUS term
    (22) if_statement -> . if OPENPAR boolean CLOSEPAR OPENCURLY statement CLOSECURLY
    (23) if_statement -> . if OPENPAR boolean CLOSEPAR OPENCURLY statement CLOSECURLY else OPENCURLY statement CLOSECURLY
    (36) term -> . term MUL factor
    (37) term -> . term DIV factor
    (38) term -> . term MOD factor
    (39) term -> . STRLIT
    (40) term -> . factor
    (26) boolean -> . expression GT term
    (27) boolean -> . expression GEQ term
    (28) boolean -> . expression LT term
    (29) boolean -> . expression LEQ term
    (30) boolean -> . expression EQ term
    (31) boolean -> . expression NEQ term
    (32) boolean -> . expression AND term
    (33) boolean -> . expression OR term
    (41) factor -> . INTLIT
    (42) factor -> . OPENPAR expression CLOSEPAR

  ! shift/reduce conflict for CLOSECURLY resolved as shift
  ! shift/reduce conflict for VAR resolved as shift
  ! shift/reduce conflict for def resolved as shift
  ! shift/reduce conflict for class resolved as shift
  ! shift/reduce conflict for print resolved as shift
  ! shift/reduce conflict for CLOSECURLY resolved as shift
  ! shift/reduce conflict for VAR resolved as shift
  ! shift/reduce conflict for def resolved as shift
  ! shift/reduce conflict for class resolved as shift
  ! shift/reduce conflict for print resolved as shift
  ! reduce/reduce conflict for if resolved using rule 3 (empty -> .)
  ! reduce/reduce conflict for STRLIT resolved using rule 3 (empty -> .)
  ! reduce/reduce conflict for INTLIT resolved using rule 3 (empty -> .)
  ! reduce/reduce conflict for OPENPAR resolved using rule 3 (empty -> .)
  ! shift/reduce conflict for if resolved as shift
  ! shift/reduce conflict for STRLIT resolved as shift
  ! shift/reduce conflict for INTLIT resolved as shift
  ! shift/reduce conflict for OPENPAR resolved as shift
    CLOSECURLY      shift and go to state 96
    VAR             shift and go to state 14
    def             shift and go to state 19
    class           shift and go to state 15
    print           shift and go to state 9
    if              shift and go to state 7
    STRLIT          shift and go to state 13
    INTLIT          shift and go to state 6
    OPENPAR         shift and go to state 4

  ! CLOSECURLY      [ reduce using rule 5 (statement_list -> statement .) ]
  ! VAR             [ reduce using rule 5 (statement_list -> statement .) ]
  ! def             [ reduce using rule 5 (statement_list -> statement .) ]
  ! class           [ reduce using rule 5 (statement_list -> statement .) ]
  ! print           [ reduce using rule 5 (statement_list -> statement .) ]
  ! if              [ reduce using rule 5 (statement_list -> statement .) ]
  ! STRLIT          [ reduce using rule 5 (statement_list -> statement .) ]
  ! INTLIT          [ reduce using rule 5 (statement_list -> statement .) ]
  ! OPENPAR         [ reduce using rule 5 (statement_list -> statement .) ]
  ! CLOSECURLY      [ reduce using rule 3 (empty -> .) ]
  ! VAR             [ reduce using rule 3 (empty -> .) ]
  ! def             [ reduce using rule 3 (empty -> .) ]
  ! class           [ reduce using rule 3 (empty -> .) ]
  ! print           [ reduce using rule 3 (empty -> .) ]
  ! if              [ reduce using rule 3 (empty -> .) ]
  ! STRLIT          [ reduce using rule 3 (empty -> .) ]
  ! INTLIT          [ reduce using rule 3 (empty -> .) ]
  ! OPENPAR         [ reduce using rule 3 (empty -> .) ]

    term                           shift and go to state 16
    expression                     shift and go to state 18
    boolean                        shift and go to state 5
    statement                      shift and go to state 23
    factor                         shift and go to state 12
    statement_list                 shift and go to state 24
    if_statement                   shift and go to state 10
    empty                          shift and go to state 11

state 89

    (16) statement -> VAR ASSIGN STRLIT TILDE return OPENPAR . VAR CLOSEPAR TILDE

    VAR             shift and go to state 97


state 90

    (14) statement -> VAR ASSIGN STRLIT TILDE scan OPENPAR . VAR CLOSEPAR TILDE

    VAR             shift and go to state 98


state 91

    (20) statement -> VAR ASSIGN STRLIT TILDE print OPENPAR . VAR CLOSEPAR TILDE

    VAR             shift and go to state 99


state 92

    (15) statement -> VAR ASSIGN expression TILDE return OPENPAR . VAR CLOSEPAR TILDE

    VAR             shift and go to state 100


state 93

    (13) statement -> VAR ASSIGN expression TILDE scan OPENPAR . VAR CLOSEPAR TILDE

    VAR             shift and go to state 101


state 94

    (19) statement -> VAR ASSIGN expression TILDE print OPENPAR . VAR CLOSEPAR TILDE

    VAR             shift and go to state 102


state 95

    (9) statement -> def VAR OPENPAR parameter CLOSEPAR OPENCURLY . statement CLOSECURLY end_def
    (2) statement -> . empty
    (4) statement -> . statement_list
    (7) statement -> . VAR ASSIGN expression TILDE
    (8) statement -> . expression TILDE
    (9) statement -> . def VAR OPENPAR parameter CLOSEPAR OPENCURLY statement CLOSECURLY end_def
    (12) statement -> . class VAR OPENCURLY statement CLOSECURLY
    (13) statement -> . VAR ASSIGN expression TILDE scan OPENPAR VAR CLOSEPAR TILDE
    (14) statement -> . VAR ASSIGN STRLIT TILDE scan OPENPAR VAR CLOSEPAR TILDE
    (15) statement -> . VAR ASSIGN expression TILDE return OPENPAR VAR CLOSEPAR TILDE
    (16) statement -> . VAR ASSIGN STRLIT TILDE return OPENPAR VAR CLOSEPAR TILDE
    (17) statement -> . print OPENPAR expression CLOSEPAR TILDE
    (18) statement -> . print OPENPAR STRLIT CLOSEPAR TILDE
    (19) statement -> . VAR ASSIGN expression TILDE print OPENPAR VAR CLOSEPAR TILDE
    (20) statement -> . VAR ASSIGN STRLIT TILDE print OPENPAR VAR CLOSEPAR TILDE
    (21) statement -> . if_statement
    (3) empty -> .
    (5) statement_list -> . statement
    (6) statement_list -> . statement statement_list
    (24) expression -> . term
    (25) expression -> . boolean
    (34) expression -> . expression PLUS term
    (35) expression -> . expression MINUS term
    (22) if_statement -> . if OPENPAR boolean CLOSEPAR OPENCURLY statement CLOSECURLY
    (23) if_statement -> . if OPENPAR boolean CLOSEPAR OPENCURLY statement CLOSECURLY else OPENCURLY statement CLOSECURLY
    (36) term -> . term MUL factor
    (37) term -> . term DIV factor
    (38) term -> . term MOD factor
    (39) term -> . STRLIT
    (40) term -> . factor
    (26) boolean -> . expression GT term
    (27) boolean -> . expression GEQ term
    (28) boolean -> . expression LT term
    (29) boolean -> . expression LEQ term
    (30) boolean -> . expression EQ term
    (31) boolean -> . expression NEQ term
    (32) boolean -> . expression AND term
    (33) boolean -> . expression OR term
    (41) factor -> . INTLIT
    (42) factor -> . OPENPAR expression CLOSEPAR

  ! shift/reduce conflict for VAR resolved as shift
  ! shift/reduce conflict for def resolved as shift
  ! shift/reduce conflict for class resolved as shift
  ! shift/reduce conflict for print resolved as shift
  ! shift/reduce conflict for if resolved as shift
  ! shift/reduce conflict for STRLIT resolved as shift
  ! shift/reduce conflict for INTLIT resolved as shift
  ! shift/reduce conflict for OPENPAR resolved as shift
    VAR             shift and go to state 14
    def             shift and go to state 19
    class           shift and go to state 15
    print           shift and go to state 9
    CLOSECURLY      reduce using rule 3 (empty -> .)
    if              shift and go to state 7
    STRLIT          shift and go to state 13
    INTLIT          shift and go to state 6
    OPENPAR         shift and go to state 4

  ! VAR             [ reduce using rule 3 (empty -> .) ]
  ! def             [ reduce using rule 3 (empty -> .) ]
  ! class           [ reduce using rule 3 (empty -> .) ]
  ! print           [ reduce using rule 3 (empty -> .) ]
  ! if              [ reduce using rule 3 (empty -> .) ]
  ! STRLIT          [ reduce using rule 3 (empty -> .) ]
  ! INTLIT          [ reduce using rule 3 (empty -> .) ]
  ! OPENPAR         [ reduce using rule 3 (empty -> .) ]

    term                           shift and go to state 16
    boolean                        shift and go to state 5
    statement                      shift and go to state 103
    factor                         shift and go to state 12
    statement_list                 shift and go to state 17
    if_statement                   shift and go to state 10
    expression                     shift and go to state 18
    empty                          shift and go to state 11

state 96

    (22) if_statement -> if OPENPAR boolean CLOSEPAR OPENCURLY statement CLOSECURLY .
    (23) if_statement -> if OPENPAR boolean CLOSEPAR OPENCURLY statement CLOSECURLY . else OPENCURLY statement CLOSECURLY

    CLOSECURLY      reduce using rule 22 (if_statement -> if OPENPAR boolean CLOSEPAR OPENCURLY statement CLOSECURLY .)
    VAR             reduce using rule 22 (if_statement -> if OPENPAR boolean CLOSEPAR OPENCURLY statement CLOSECURLY .)
    def             reduce using rule 22 (if_statement -> if OPENPAR boolean CLOSEPAR OPENCURLY statement CLOSECURLY .)
    class           reduce using rule 22 (if_statement -> if OPENPAR boolean CLOSEPAR OPENCURLY statement CLOSECURLY .)
    print           reduce using rule 22 (if_statement -> if OPENPAR boolean CLOSEPAR OPENCURLY statement CLOSECURLY .)
    if              reduce using rule 22 (if_statement -> if OPENPAR boolean CLOSEPAR OPENCURLY statement CLOSECURLY .)
    STRLIT          reduce using rule 22 (if_statement -> if OPENPAR boolean CLOSEPAR OPENCURLY statement CLOSECURLY .)
    INTLIT          reduce using rule 22 (if_statement -> if OPENPAR boolean CLOSEPAR OPENCURLY statement CLOSECURLY .)
    OPENPAR         reduce using rule 22 (if_statement -> if OPENPAR boolean CLOSEPAR OPENCURLY statement CLOSECURLY .)
    else            shift and go to state 104


state 97

    (16) statement -> VAR ASSIGN STRLIT TILDE return OPENPAR VAR . CLOSEPAR TILDE

    CLOSEPAR        shift and go to state 105


state 98

    (14) statement -> VAR ASSIGN STRLIT TILDE scan OPENPAR VAR . CLOSEPAR TILDE

    CLOSEPAR        shift and go to state 106


state 99

    (20) statement -> VAR ASSIGN STRLIT TILDE print OPENPAR VAR . CLOSEPAR TILDE

    CLOSEPAR        shift and go to state 107


state 100

    (15) statement -> VAR ASSIGN expression TILDE return OPENPAR VAR . CLOSEPAR TILDE

    CLOSEPAR        shift and go to state 108


state 101

    (13) statement -> VAR ASSIGN expression TILDE scan OPENPAR VAR . CLOSEPAR TILDE

    CLOSEPAR        shift and go to state 109


state 102

    (19) statement -> VAR ASSIGN expression TILDE print OPENPAR VAR . CLOSEPAR TILDE

    CLOSEPAR        shift and go to state 110


state 103

    (9) statement -> def VAR OPENPAR parameter CLOSEPAR OPENCURLY statement . CLOSECURLY end_def
    (5) statement_list -> statement .
    (6) statement_list -> statement . statement_list
    (5) statement_list -> . statement
    (6) statement_list -> . statement statement_list
    (2) statement -> . empty
    (4) statement -> . statement_list
    (7) statement -> . VAR ASSIGN expression TILDE
    (8) statement -> . expression TILDE
    (9) statement -> . def VAR OPENPAR parameter CLOSEPAR OPENCURLY statement CLOSECURLY end_def
    (12) statement -> . class VAR OPENCURLY statement CLOSECURLY
    (13) statement -> . VAR ASSIGN expression TILDE scan OPENPAR VAR CLOSEPAR TILDE
    (14) statement -> . VAR ASSIGN STRLIT TILDE scan OPENPAR VAR CLOSEPAR TILDE
    (15) statement -> . VAR ASSIGN expression TILDE return OPENPAR VAR CLOSEPAR TILDE
    (16) statement -> . VAR ASSIGN STRLIT TILDE return OPENPAR VAR CLOSEPAR TILDE
    (17) statement -> . print OPENPAR expression CLOSEPAR TILDE
    (18) statement -> . print OPENPAR STRLIT CLOSEPAR TILDE
    (19) statement -> . VAR ASSIGN expression TILDE print OPENPAR VAR CLOSEPAR TILDE
    (20) statement -> . VAR ASSIGN STRLIT TILDE print OPENPAR VAR CLOSEPAR TILDE
    (21) statement -> . if_statement
    (3) empty -> .
    (24) expression -> . term
    (25) expression -> . boolean
    (34) expression -> . expression PLUS term
    (35) expression -> . expression MINUS term
    (22) if_statement -> . if OPENPAR boolean CLOSEPAR OPENCURLY statement CLOSECURLY
    (23) if_statement -> . if OPENPAR boolean CLOSEPAR OPENCURLY statement CLOSECURLY else OPENCURLY statement CLOSECURLY
    (36) term -> . term MUL factor
    (37) term -> . term DIV factor
    (38) term -> . term MOD factor
    (39) term -> . STRLIT
    (40) term -> . factor
    (26) boolean -> . expression GT term
    (27) boolean -> . expression GEQ term
    (28) boolean -> . expression LT term
    (29) boolean -> . expression LEQ term
    (30) boolean -> . expression EQ term
    (31) boolean -> . expression NEQ term
    (32) boolean -> . expression AND term
    (33) boolean -> . expression OR term
    (41) factor -> . INTLIT
    (42) factor -> . OPENPAR expression CLOSEPAR

  ! shift/reduce conflict for CLOSECURLY resolved as shift
  ! shift/reduce conflict for VAR resolved as shift
  ! shift/reduce conflict for def resolved as shift
  ! shift/reduce conflict for class resolved as shift
  ! shift/reduce conflict for print resolved as shift
  ! shift/reduce conflict for CLOSECURLY resolved as shift
  ! shift/reduce conflict for VAR resolved as shift
  ! shift/reduce conflict for def resolved as shift
  ! shift/reduce conflict for class resolved as shift
  ! shift/reduce conflict for print resolved as shift
  ! reduce/reduce conflict for if resolved using rule 3 (empty -> .)
  ! reduce/reduce conflict for STRLIT resolved using rule 3 (empty -> .)
  ! reduce/reduce conflict for INTLIT resolved using rule 3 (empty -> .)
  ! reduce/reduce conflict for OPENPAR resolved using rule 3 (empty -> .)
  ! shift/reduce conflict for if resolved as shift
  ! shift/reduce conflict for STRLIT resolved as shift
  ! shift/reduce conflict for INTLIT resolved as shift
  ! shift/reduce conflict for OPENPAR resolved as shift
    CLOSECURLY      shift and go to state 111
    VAR             shift and go to state 14
    def             shift and go to state 19
    class           shift and go to state 15
    print           shift and go to state 9
    if              shift and go to state 7
    STRLIT          shift and go to state 13
    INTLIT          shift and go to state 6
    OPENPAR         shift and go to state 4

  ! CLOSECURLY      [ reduce using rule 5 (statement_list -> statement .) ]
  ! VAR             [ reduce using rule 5 (statement_list -> statement .) ]
  ! def             [ reduce using rule 5 (statement_list -> statement .) ]
  ! class           [ reduce using rule 5 (statement_list -> statement .) ]
  ! print           [ reduce using rule 5 (statement_list -> statement .) ]
  ! if              [ reduce using rule 5 (statement_list -> statement .) ]
  ! STRLIT          [ reduce using rule 5 (statement_list -> statement .) ]
  ! INTLIT          [ reduce using rule 5 (statement_list -> statement .) ]
  ! OPENPAR         [ reduce using rule 5 (statement_list -> statement .) ]
  ! CLOSECURLY      [ reduce using rule 3 (empty -> .) ]
  ! VAR             [ reduce using rule 3 (empty -> .) ]
  ! def             [ reduce using rule 3 (empty -> .) ]
  ! class           [ reduce using rule 3 (empty -> .) ]
  ! print           [ reduce using rule 3 (empty -> .) ]
  ! if              [ reduce using rule 3 (empty -> .) ]
  ! STRLIT          [ reduce using rule 3 (empty -> .) ]
  ! INTLIT          [ reduce using rule 3 (empty -> .) ]
  ! OPENPAR         [ reduce using rule 3 (empty -> .) ]

    term                           shift and go to state 16
    boolean                        shift and go to state 5
    statement                      shift and go to state 23
    factor                         shift and go to state 12
    statement_list                 shift and go to state 24
    if_statement                   shift and go to state 10
    expression                     shift and go to state 18
    empty                          shift and go to state 11

state 104

    (23) if_statement -> if OPENPAR boolean CLOSEPAR OPENCURLY statement CLOSECURLY else . OPENCURLY statement CLOSECURLY

    OPENCURLY       shift and go to state 112


state 105

    (16) statement -> VAR ASSIGN STRLIT TILDE return OPENPAR VAR CLOSEPAR . TILDE

    TILDE           shift and go to state 113


state 106

    (14) statement -> VAR ASSIGN STRLIT TILDE scan OPENPAR VAR CLOSEPAR . TILDE

    TILDE           shift and go to state 114


state 107

    (20) statement -> VAR ASSIGN STRLIT TILDE print OPENPAR VAR CLOSEPAR . TILDE

    TILDE           shift and go to state 115


state 108

    (15) statement -> VAR ASSIGN expression TILDE return OPENPAR VAR CLOSEPAR . TILDE

    TILDE           shift and go to state 116


state 109

    (13) statement -> VAR ASSIGN expression TILDE scan OPENPAR VAR CLOSEPAR . TILDE

    TILDE           shift and go to state 117


state 110

    (19) statement -> VAR ASSIGN expression TILDE print OPENPAR VAR CLOSEPAR . TILDE

    TILDE           shift and go to state 118


state 111

    (9) statement -> def VAR OPENPAR parameter CLOSEPAR OPENCURLY statement CLOSECURLY . end_def

    end_def         shift and go to state 119


state 112

    (23) if_statement -> if OPENPAR boolean CLOSEPAR OPENCURLY statement CLOSECURLY else OPENCURLY . statement CLOSECURLY
    (2) statement -> . empty
    (4) statement -> . statement_list
    (7) statement -> . VAR ASSIGN expression TILDE
    (8) statement -> . expression TILDE
    (9) statement -> . def VAR OPENPAR parameter CLOSEPAR OPENCURLY statement CLOSECURLY end_def
    (12) statement -> . class VAR OPENCURLY statement CLOSECURLY
    (13) statement -> . VAR ASSIGN expression TILDE scan OPENPAR VAR CLOSEPAR TILDE
    (14) statement -> . VAR ASSIGN STRLIT TILDE scan OPENPAR VAR CLOSEPAR TILDE
    (15) statement -> . VAR ASSIGN expression TILDE return OPENPAR VAR CLOSEPAR TILDE
    (16) statement -> . VAR ASSIGN STRLIT TILDE return OPENPAR VAR CLOSEPAR TILDE
    (17) statement -> . print OPENPAR expression CLOSEPAR TILDE
    (18) statement -> . print OPENPAR STRLIT CLOSEPAR TILDE
    (19) statement -> . VAR ASSIGN expression TILDE print OPENPAR VAR CLOSEPAR TILDE
    (20) statement -> . VAR ASSIGN STRLIT TILDE print OPENPAR VAR CLOSEPAR TILDE
    (21) statement -> . if_statement
    (3) empty -> .
    (5) statement_list -> . statement
    (6) statement_list -> . statement statement_list
    (24) expression -> . term
    (25) expression -> . boolean
    (34) expression -> . expression PLUS term
    (35) expression -> . expression MINUS term
    (22) if_statement -> . if OPENPAR boolean CLOSEPAR OPENCURLY statement CLOSECURLY
    (23) if_statement -> . if OPENPAR boolean CLOSEPAR OPENCURLY statement CLOSECURLY else OPENCURLY statement CLOSECURLY
    (36) term -> . term MUL factor
    (37) term -> . term DIV factor
    (38) term -> . term MOD factor
    (39) term -> . STRLIT
    (40) term -> . factor
    (26) boolean -> . expression GT term
    (27) boolean -> . expression GEQ term
    (28) boolean -> . expression LT term
    (29) boolean -> . expression LEQ term
    (30) boolean -> . expression EQ term
    (31) boolean -> . expression NEQ term
    (32) boolean -> . expression AND term
    (33) boolean -> . expression OR term
    (41) factor -> . INTLIT
    (42) factor -> . OPENPAR expression CLOSEPAR

  ! shift/reduce conflict for VAR resolved as shift
  ! shift/reduce conflict for def resolved as shift
  ! shift/reduce conflict for class resolved as shift
  ! shift/reduce conflict for print resolved as shift
  ! shift/reduce conflict for if resolved as shift
  ! shift/reduce conflict for STRLIT resolved as shift
  ! shift/reduce conflict for INTLIT resolved as shift
  ! shift/reduce conflict for OPENPAR resolved as shift
    VAR             shift and go to state 14
    def             shift and go to state 19
    class           shift and go to state 15
    print           shift and go to state 9
    CLOSECURLY      reduce using rule 3 (empty -> .)
    if              shift and go to state 7
    STRLIT          shift and go to state 13
    INTLIT          shift and go to state 6
    OPENPAR         shift and go to state 4

  ! VAR             [ reduce using rule 3 (empty -> .) ]
  ! def             [ reduce using rule 3 (empty -> .) ]
  ! class           [ reduce using rule 3 (empty -> .) ]
  ! print           [ reduce using rule 3 (empty -> .) ]
  ! if              [ reduce using rule 3 (empty -> .) ]
  ! STRLIT          [ reduce using rule 3 (empty -> .) ]
  ! INTLIT          [ reduce using rule 3 (empty -> .) ]
  ! OPENPAR         [ reduce using rule 3 (empty -> .) ]

    term                           shift and go to state 16
    expression                     shift and go to state 18
    boolean                        shift and go to state 5
    statement                      shift and go to state 120
    factor                         shift and go to state 12
    statement_list                 shift and go to state 17
    if_statement                   shift and go to state 10
    empty                          shift and go to state 11

state 113

    (16) statement -> VAR ASSIGN STRLIT TILDE return OPENPAR VAR CLOSEPAR TILDE .

    CLOSECURLY      reduce using rule 16 (statement -> VAR ASSIGN STRLIT TILDE return OPENPAR VAR CLOSEPAR TILDE .)
    VAR             reduce using rule 16 (statement -> VAR ASSIGN STRLIT TILDE return OPENPAR VAR CLOSEPAR TILDE .)
    def             reduce using rule 16 (statement -> VAR ASSIGN STRLIT TILDE return OPENPAR VAR CLOSEPAR TILDE .)
    class           reduce using rule 16 (statement -> VAR ASSIGN STRLIT TILDE return OPENPAR VAR CLOSEPAR TILDE .)
    print           reduce using rule 16 (statement -> VAR ASSIGN STRLIT TILDE return OPENPAR VAR CLOSEPAR TILDE .)
    if              reduce using rule 16 (statement -> VAR ASSIGN STRLIT TILDE return OPENPAR VAR CLOSEPAR TILDE .)
    STRLIT          reduce using rule 16 (statement -> VAR ASSIGN STRLIT TILDE return OPENPAR VAR CLOSEPAR TILDE .)
    INTLIT          reduce using rule 16 (statement -> VAR ASSIGN STRLIT TILDE return OPENPAR VAR CLOSEPAR TILDE .)
    OPENPAR         reduce using rule 16 (statement -> VAR ASSIGN STRLIT TILDE return OPENPAR VAR CLOSEPAR TILDE .)


state 114

    (14) statement -> VAR ASSIGN STRLIT TILDE scan OPENPAR VAR CLOSEPAR TILDE .

    CLOSECURLY      reduce using rule 14 (statement -> VAR ASSIGN STRLIT TILDE scan OPENPAR VAR CLOSEPAR TILDE .)
    VAR             reduce using rule 14 (statement -> VAR ASSIGN STRLIT TILDE scan OPENPAR VAR CLOSEPAR TILDE .)
    def             reduce using rule 14 (statement -> VAR ASSIGN STRLIT TILDE scan OPENPAR VAR CLOSEPAR TILDE .)
    class           reduce using rule 14 (statement -> VAR ASSIGN STRLIT TILDE scan OPENPAR VAR CLOSEPAR TILDE .)
    print           reduce using rule 14 (statement -> VAR ASSIGN STRLIT TILDE scan OPENPAR VAR CLOSEPAR TILDE .)
    if              reduce using rule 14 (statement -> VAR ASSIGN STRLIT TILDE scan OPENPAR VAR CLOSEPAR TILDE .)
    STRLIT          reduce using rule 14 (statement -> VAR ASSIGN STRLIT TILDE scan OPENPAR VAR CLOSEPAR TILDE .)
    INTLIT          reduce using rule 14 (statement -> VAR ASSIGN STRLIT TILDE scan OPENPAR VAR CLOSEPAR TILDE .)
    OPENPAR         reduce using rule 14 (statement -> VAR ASSIGN STRLIT TILDE scan OPENPAR VAR CLOSEPAR TILDE .)


state 115

    (20) statement -> VAR ASSIGN STRLIT TILDE print OPENPAR VAR CLOSEPAR TILDE .

    CLOSECURLY      reduce using rule 20 (statement -> VAR ASSIGN STRLIT TILDE print OPENPAR VAR CLOSEPAR TILDE .)
    VAR             reduce using rule 20 (statement -> VAR ASSIGN STRLIT TILDE print OPENPAR VAR CLOSEPAR TILDE .)
    def             reduce using rule 20 (statement -> VAR ASSIGN STRLIT TILDE print OPENPAR VAR CLOSEPAR TILDE .)
    class           reduce using rule 20 (statement -> VAR ASSIGN STRLIT TILDE print OPENPAR VAR CLOSEPAR TILDE .)
    print           reduce using rule 20 (statement -> VAR ASSIGN STRLIT TILDE print OPENPAR VAR CLOSEPAR TILDE .)
    if              reduce using rule 20 (statement -> VAR ASSIGN STRLIT TILDE print OPENPAR VAR CLOSEPAR TILDE .)
    STRLIT          reduce using rule 20 (statement -> VAR ASSIGN STRLIT TILDE print OPENPAR VAR CLOSEPAR TILDE .)
    INTLIT          reduce using rule 20 (statement -> VAR ASSIGN STRLIT TILDE print OPENPAR VAR CLOSEPAR TILDE .)
    OPENPAR         reduce using rule 20 (statement -> VAR ASSIGN STRLIT TILDE print OPENPAR VAR CLOSEPAR TILDE .)


state 116

    (15) statement -> VAR ASSIGN expression TILDE return OPENPAR VAR CLOSEPAR TILDE .

    CLOSECURLY      reduce using rule 15 (statement -> VAR ASSIGN expression TILDE return OPENPAR VAR CLOSEPAR TILDE .)
    VAR             reduce using rule 15 (statement -> VAR ASSIGN expression TILDE return OPENPAR VAR CLOSEPAR TILDE .)
    def             reduce using rule 15 (statement -> VAR ASSIGN expression TILDE return OPENPAR VAR CLOSEPAR TILDE .)
    class           reduce using rule 15 (statement -> VAR ASSIGN expression TILDE return OPENPAR VAR CLOSEPAR TILDE .)
    print           reduce using rule 15 (statement -> VAR ASSIGN expression TILDE return OPENPAR VAR CLOSEPAR TILDE .)
    if              reduce using rule 15 (statement -> VAR ASSIGN expression TILDE return OPENPAR VAR CLOSEPAR TILDE .)
    STRLIT          reduce using rule 15 (statement -> VAR ASSIGN expression TILDE return OPENPAR VAR CLOSEPAR TILDE .)
    INTLIT          reduce using rule 15 (statement -> VAR ASSIGN expression TILDE return OPENPAR VAR CLOSEPAR TILDE .)
    OPENPAR         reduce using rule 15 (statement -> VAR ASSIGN expression TILDE return OPENPAR VAR CLOSEPAR TILDE .)


state 117

    (13) statement -> VAR ASSIGN expression TILDE scan OPENPAR VAR CLOSEPAR TILDE .

    CLOSECURLY      reduce using rule 13 (statement -> VAR ASSIGN expression TILDE scan OPENPAR VAR CLOSEPAR TILDE .)
    VAR             reduce using rule 13 (statement -> VAR ASSIGN expression TILDE scan OPENPAR VAR CLOSEPAR TILDE .)
    def             reduce using rule 13 (statement -> VAR ASSIGN expression TILDE scan OPENPAR VAR CLOSEPAR TILDE .)
    class           reduce using rule 13 (statement -> VAR ASSIGN expression TILDE scan OPENPAR VAR CLOSEPAR TILDE .)
    print           reduce using rule 13 (statement -> VAR ASSIGN expression TILDE scan OPENPAR VAR CLOSEPAR TILDE .)
    if              reduce using rule 13 (statement -> VAR ASSIGN expression TILDE scan OPENPAR VAR CLOSEPAR TILDE .)
    STRLIT          reduce using rule 13 (statement -> VAR ASSIGN expression TILDE scan OPENPAR VAR CLOSEPAR TILDE .)
    INTLIT          reduce using rule 13 (statement -> VAR ASSIGN expression TILDE scan OPENPAR VAR CLOSEPAR TILDE .)
    OPENPAR         reduce using rule 13 (statement -> VAR ASSIGN expression TILDE scan OPENPAR VAR CLOSEPAR TILDE .)


state 118

    (19) statement -> VAR ASSIGN expression TILDE print OPENPAR VAR CLOSEPAR TILDE .

    CLOSECURLY      reduce using rule 19 (statement -> VAR ASSIGN expression TILDE print OPENPAR VAR CLOSEPAR TILDE .)
    VAR             reduce using rule 19 (statement -> VAR ASSIGN expression TILDE print OPENPAR VAR CLOSEPAR TILDE .)
    def             reduce using rule 19 (statement -> VAR ASSIGN expression TILDE print OPENPAR VAR CLOSEPAR TILDE .)
    class           reduce using rule 19 (statement -> VAR ASSIGN expression TILDE print OPENPAR VAR CLOSEPAR TILDE .)
    print           reduce using rule 19 (statement -> VAR ASSIGN expression TILDE print OPENPAR VAR CLOSEPAR TILDE .)
    if              reduce using rule 19 (statement -> VAR ASSIGN expression TILDE print OPENPAR VAR CLOSEPAR TILDE .)
    STRLIT          reduce using rule 19 (statement -> VAR ASSIGN expression TILDE print OPENPAR VAR CLOSEPAR TILDE .)
    INTLIT          reduce using rule 19 (statement -> VAR ASSIGN expression TILDE print OPENPAR VAR CLOSEPAR TILDE .)
    OPENPAR         reduce using rule 19 (statement -> VAR ASSIGN expression TILDE print OPENPAR VAR CLOSEPAR TILDE .)


state 119

    (9) statement -> def VAR OPENPAR parameter CLOSEPAR OPENCURLY statement CLOSECURLY end_def .

    CLOSECURLY      reduce using rule 9 (statement -> def VAR OPENPAR parameter CLOSEPAR OPENCURLY statement CLOSECURLY end_def .)
    VAR             reduce using rule 9 (statement -> def VAR OPENPAR parameter CLOSEPAR OPENCURLY statement CLOSECURLY end_def .)
    def             reduce using rule 9 (statement -> def VAR OPENPAR parameter CLOSEPAR OPENCURLY statement CLOSECURLY end_def .)
    class           reduce using rule 9 (statement -> def VAR OPENPAR parameter CLOSEPAR OPENCURLY statement CLOSECURLY end_def .)
    print           reduce using rule 9 (statement -> def VAR OPENPAR parameter CLOSEPAR OPENCURLY statement CLOSECURLY end_def .)
    if              reduce using rule 9 (statement -> def VAR OPENPAR parameter CLOSEPAR OPENCURLY statement CLOSECURLY end_def .)
    STRLIT          reduce using rule 9 (statement -> def VAR OPENPAR parameter CLOSEPAR OPENCURLY statement CLOSECURLY end_def .)
    INTLIT          reduce using rule 9 (statement -> def VAR OPENPAR parameter CLOSEPAR OPENCURLY statement CLOSECURLY end_def .)
    OPENPAR         reduce using rule 9 (statement -> def VAR OPENPAR parameter CLOSEPAR OPENCURLY statement CLOSECURLY end_def .)


state 120

    (23) if_statement -> if OPENPAR boolean CLOSEPAR OPENCURLY statement CLOSECURLY else OPENCURLY statement . CLOSECURLY
    (5) statement_list -> statement .
    (6) statement_list -> statement . statement_list
    (5) statement_list -> . statement
    (6) statement_list -> . statement statement_list
    (2) statement -> . empty
    (4) statement -> . statement_list
    (7) statement -> . VAR ASSIGN expression TILDE
    (8) statement -> . expression TILDE
    (9) statement -> . def VAR OPENPAR parameter CLOSEPAR OPENCURLY statement CLOSECURLY end_def
    (12) statement -> . class VAR OPENCURLY statement CLOSECURLY
    (13) statement -> . VAR ASSIGN expression TILDE scan OPENPAR VAR CLOSEPAR TILDE
    (14) statement -> . VAR ASSIGN STRLIT TILDE scan OPENPAR VAR CLOSEPAR TILDE
    (15) statement -> . VAR ASSIGN expression TILDE return OPENPAR VAR CLOSEPAR TILDE
    (16) statement -> . VAR ASSIGN STRLIT TILDE return OPENPAR VAR CLOSEPAR TILDE
    (17) statement -> . print OPENPAR expression CLOSEPAR TILDE
    (18) statement -> . print OPENPAR STRLIT CLOSEPAR TILDE
    (19) statement -> . VAR ASSIGN expression TILDE print OPENPAR VAR CLOSEPAR TILDE
    (20) statement -> . VAR ASSIGN STRLIT TILDE print OPENPAR VAR CLOSEPAR TILDE
    (21) statement -> . if_statement
    (3) empty -> .
    (24) expression -> . term
    (25) expression -> . boolean
    (34) expression -> . expression PLUS term
    (35) expression -> . expression MINUS term
    (22) if_statement -> . if OPENPAR boolean CLOSEPAR OPENCURLY statement CLOSECURLY
    (23) if_statement -> . if OPENPAR boolean CLOSEPAR OPENCURLY statement CLOSECURLY else OPENCURLY statement CLOSECURLY
    (36) term -> . term MUL factor
    (37) term -> . term DIV factor
    (38) term -> . term MOD factor
    (39) term -> . STRLIT
    (40) term -> . factor
    (26) boolean -> . expression GT term
    (27) boolean -> . expression GEQ term
    (28) boolean -> . expression LT term
    (29) boolean -> . expression LEQ term
    (30) boolean -> . expression EQ term
    (31) boolean -> . expression NEQ term
    (32) boolean -> . expression AND term
    (33) boolean -> . expression OR term
    (41) factor -> . INTLIT
    (42) factor -> . OPENPAR expression CLOSEPAR

  ! shift/reduce conflict for CLOSECURLY resolved as shift
  ! shift/reduce conflict for VAR resolved as shift
  ! shift/reduce conflict for def resolved as shift
  ! shift/reduce conflict for class resolved as shift
  ! shift/reduce conflict for print resolved as shift
  ! shift/reduce conflict for CLOSECURLY resolved as shift
  ! shift/reduce conflict for VAR resolved as shift
  ! shift/reduce conflict for def resolved as shift
  ! shift/reduce conflict for class resolved as shift
  ! shift/reduce conflict for print resolved as shift
  ! reduce/reduce conflict for if resolved using rule 3 (empty -> .)
  ! reduce/reduce conflict for STRLIT resolved using rule 3 (empty -> .)
  ! reduce/reduce conflict for INTLIT resolved using rule 3 (empty -> .)
  ! reduce/reduce conflict for OPENPAR resolved using rule 3 (empty -> .)
  ! shift/reduce conflict for if resolved as shift
  ! shift/reduce conflict for STRLIT resolved as shift
  ! shift/reduce conflict for INTLIT resolved as shift
  ! shift/reduce conflict for OPENPAR resolved as shift
    CLOSECURLY      shift and go to state 121
    VAR             shift and go to state 14
    def             shift and go to state 19
    class           shift and go to state 15
    print           shift and go to state 9
    if              shift and go to state 7
    STRLIT          shift and go to state 13
    INTLIT          shift and go to state 6
    OPENPAR         shift and go to state 4

  ! CLOSECURLY      [ reduce using rule 5 (statement_list -> statement .) ]
  ! VAR             [ reduce using rule 5 (statement_list -> statement .) ]
  ! def             [ reduce using rule 5 (statement_list -> statement .) ]
  ! class           [ reduce using rule 5 (statement_list -> statement .) ]
  ! print           [ reduce using rule 5 (statement_list -> statement .) ]
  ! if              [ reduce using rule 5 (statement_list -> statement .) ]
  ! STRLIT          [ reduce using rule 5 (statement_list -> statement .) ]
  ! INTLIT          [ reduce using rule 5 (statement_list -> statement .) ]
  ! OPENPAR         [ reduce using rule 5 (statement_list -> statement .) ]
  ! CLOSECURLY      [ reduce using rule 3 (empty -> .) ]
  ! VAR             [ reduce using rule 3 (empty -> .) ]
  ! def             [ reduce using rule 3 (empty -> .) ]
  ! class           [ reduce using rule 3 (empty -> .) ]
  ! print           [ reduce using rule 3 (empty -> .) ]
  ! if              [ reduce using rule 3 (empty -> .) ]
  ! STRLIT          [ reduce using rule 3 (empty -> .) ]
  ! INTLIT          [ reduce using rule 3 (empty -> .) ]
  ! OPENPAR         [ reduce using rule 3 (empty -> .) ]

    term                           shift and go to state 16
    expression                     shift and go to state 18
    boolean                        shift and go to state 5
    statement                      shift and go to state 23
    factor                         shift and go to state 12
    statement_list                 shift and go to state 24
    if_statement                   shift and go to state 10
    empty                          shift and go to state 11

state 121

    (23) if_statement -> if OPENPAR boolean CLOSEPAR OPENCURLY statement CLOSECURLY else OPENCURLY statement CLOSECURLY .

    CLOSECURLY      reduce using rule 23 (if_statement -> if OPENPAR boolean CLOSEPAR OPENCURLY statement CLOSECURLY else OPENCURLY statement CLOSECURLY .)
    VAR             reduce using rule 23 (if_statement -> if OPENPAR boolean CLOSEPAR OPENCURLY statement CLOSECURLY else OPENCURLY statement CLOSECURLY .)
    def             reduce using rule 23 (if_statement -> if OPENPAR boolean CLOSEPAR OPENCURLY statement CLOSECURLY else OPENCURLY statement CLOSECURLY .)
    class           reduce using rule 23 (if_statement -> if OPENPAR boolean CLOSEPAR OPENCURLY statement CLOSECURLY else OPENCURLY statement CLOSECURLY .)
    print           reduce using rule 23 (if_statement -> if OPENPAR boolean CLOSEPAR OPENCURLY statement CLOSECURLY else OPENCURLY statement CLOSECURLY .)
    if              reduce using rule 23 (if_statement -> if OPENPAR boolean CLOSEPAR OPENCURLY statement CLOSECURLY else OPENCURLY statement CLOSECURLY .)
    STRLIT          reduce using rule 23 (if_statement -> if OPENPAR boolean CLOSEPAR OPENCURLY statement CLOSECURLY else OPENCURLY statement CLOSECURLY .)
    INTLIT          reduce using rule 23 (if_statement -> if OPENPAR boolean CLOSEPAR OPENCURLY statement CLOSECURLY else OPENCURLY statement CLOSECURLY .)
    OPENPAR         reduce using rule 23 (if_statement -> if OPENPAR boolean CLOSEPAR OPENCURLY statement CLOSECURLY else OPENCURLY statement CLOSECURLY .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for VAR in state 3 resolved as shift
WARNING: shift/reduce conflict for def in state 3 resolved as shift
WARNING: shift/reduce conflict for class in state 3 resolved as shift
WARNING: shift/reduce conflict for print in state 3 resolved as shift
WARNING: shift/reduce conflict for if in state 3 resolved as shift
WARNING: shift/reduce conflict for STRLIT in state 3 resolved as shift
WARNING: shift/reduce conflict for INTLIT in state 3 resolved as shift
WARNING: shift/reduce conflict for OPENPAR in state 3 resolved as shift
WARNING: shift/reduce conflict for CLOSECURLY in state 8 resolved as shift
WARNING: shift/reduce conflict for VAR in state 8 resolved as shift
WARNING: shift/reduce conflict for def in state 8 resolved as shift
WARNING: shift/reduce conflict for class in state 8 resolved as shift
WARNING: shift/reduce conflict for print in state 8 resolved as shift
WARNING: shift/reduce conflict for CLOSECURLY in state 8 resolved as shift
WARNING: shift/reduce conflict for VAR in state 8 resolved as shift
WARNING: shift/reduce conflict for def in state 8 resolved as shift
WARNING: shift/reduce conflict for class in state 8 resolved as shift
WARNING: shift/reduce conflict for print in state 8 resolved as shift
WARNING: shift/reduce conflict for if in state 8 resolved as shift
WARNING: shift/reduce conflict for STRLIT in state 8 resolved as shift
WARNING: shift/reduce conflict for INTLIT in state 8 resolved as shift
WARNING: shift/reduce conflict for OPENPAR in state 8 resolved as shift
WARNING: shift/reduce conflict for VAR in state 23 resolved as shift
WARNING: shift/reduce conflict for def in state 23 resolved as shift
WARNING: shift/reduce conflict for class in state 23 resolved as shift
WARNING: shift/reduce conflict for print in state 23 resolved as shift
WARNING: shift/reduce conflict for VAR in state 23 resolved as shift
WARNING: shift/reduce conflict for def in state 23 resolved as shift
WARNING: shift/reduce conflict for class in state 23 resolved as shift
WARNING: shift/reduce conflict for print in state 23 resolved as shift
WARNING: shift/reduce conflict for if in state 23 resolved as shift
WARNING: shift/reduce conflict for STRLIT in state 23 resolved as shift
WARNING: shift/reduce conflict for INTLIT in state 23 resolved as shift
WARNING: shift/reduce conflict for OPENPAR in state 23 resolved as shift
WARNING: shift/reduce conflict for CLOSEPAR in state 47 resolved as shift
WARNING: shift/reduce conflict for TILDE in state 49 resolved as shift
WARNING: shift/reduce conflict for VAR in state 51 resolved as shift
WARNING: shift/reduce conflict for def in state 51 resolved as shift
WARNING: shift/reduce conflict for class in state 51 resolved as shift
WARNING: shift/reduce conflict for print in state 51 resolved as shift
WARNING: shift/reduce conflict for if in state 51 resolved as shift
WARNING: shift/reduce conflict for STRLIT in state 51 resolved as shift
WARNING: shift/reduce conflict for INTLIT in state 51 resolved as shift
WARNING: shift/reduce conflict for OPENPAR in state 51 resolved as shift
WARNING: shift/reduce conflict for print in state 70 resolved as shift
WARNING: shift/reduce conflict for CLOSECURLY in state 71 resolved as shift
WARNING: shift/reduce conflict for VAR in state 71 resolved as shift
WARNING: shift/reduce conflict for def in state 71 resolved as shift
WARNING: shift/reduce conflict for class in state 71 resolved as shift
WARNING: shift/reduce conflict for print in state 71 resolved as shift
WARNING: shift/reduce conflict for CLOSECURLY in state 71 resolved as shift
WARNING: shift/reduce conflict for VAR in state 71 resolved as shift
WARNING: shift/reduce conflict for def in state 71 resolved as shift
WARNING: shift/reduce conflict for class in state 71 resolved as shift
WARNING: shift/reduce conflict for print in state 71 resolved as shift
WARNING: shift/reduce conflict for if in state 71 resolved as shift
WARNING: shift/reduce conflict for STRLIT in state 71 resolved as shift
WARNING: shift/reduce conflict for INTLIT in state 71 resolved as shift
WARNING: shift/reduce conflict for OPENPAR in state 71 resolved as shift
WARNING: shift/reduce conflict for VAR in state 75 resolved as shift
WARNING: shift/reduce conflict for def in state 75 resolved as shift
WARNING: shift/reduce conflict for class in state 75 resolved as shift
WARNING: shift/reduce conflict for print in state 75 resolved as shift
WARNING: shift/reduce conflict for if in state 75 resolved as shift
WARNING: shift/reduce conflict for STRLIT in state 75 resolved as shift
WARNING: shift/reduce conflict for INTLIT in state 75 resolved as shift
WARNING: shift/reduce conflict for OPENPAR in state 75 resolved as shift
WARNING: shift/reduce conflict for CLOSECURLY in state 88 resolved as shift
WARNING: shift/reduce conflict for VAR in state 88 resolved as shift
WARNING: shift/reduce conflict for def in state 88 resolved as shift
WARNING: shift/reduce conflict for class in state 88 resolved as shift
WARNING: shift/reduce conflict for print in state 88 resolved as shift
WARNING: shift/reduce conflict for CLOSECURLY in state 88 resolved as shift
WARNING: shift/reduce conflict for VAR in state 88 resolved as shift
WARNING: shift/reduce conflict for def in state 88 resolved as shift
WARNING: shift/reduce conflict for class in state 88 resolved as shift
WARNING: shift/reduce conflict for print in state 88 resolved as shift
WARNING: shift/reduce conflict for if in state 88 resolved as shift
WARNING: shift/reduce conflict for STRLIT in state 88 resolved as shift
WARNING: shift/reduce conflict for INTLIT in state 88 resolved as shift
WARNING: shift/reduce conflict for OPENPAR in state 88 resolved as shift
WARNING: shift/reduce conflict for VAR in state 95 resolved as shift
WARNING: shift/reduce conflict for def in state 95 resolved as shift
WARNING: shift/reduce conflict for class in state 95 resolved as shift
WARNING: shift/reduce conflict for print in state 95 resolved as shift
WARNING: shift/reduce conflict for if in state 95 resolved as shift
WARNING: shift/reduce conflict for STRLIT in state 95 resolved as shift
WARNING: shift/reduce conflict for INTLIT in state 95 resolved as shift
WARNING: shift/reduce conflict for OPENPAR in state 95 resolved as shift
WARNING: shift/reduce conflict for CLOSECURLY in state 103 resolved as shift
WARNING: shift/reduce conflict for VAR in state 103 resolved as shift
WARNING: shift/reduce conflict for def in state 103 resolved as shift
WARNING: shift/reduce conflict for class in state 103 resolved as shift
WARNING: shift/reduce conflict for print in state 103 resolved as shift
WARNING: shift/reduce conflict for CLOSECURLY in state 103 resolved as shift
WARNING: shift/reduce conflict for VAR in state 103 resolved as shift
WARNING: shift/reduce conflict for def in state 103 resolved as shift
WARNING: shift/reduce conflict for class in state 103 resolved as shift
WARNING: shift/reduce conflict for print in state 103 resolved as shift
WARNING: shift/reduce conflict for if in state 103 resolved as shift
WARNING: shift/reduce conflict for STRLIT in state 103 resolved as shift
WARNING: shift/reduce conflict for INTLIT in state 103 resolved as shift
WARNING: shift/reduce conflict for OPENPAR in state 103 resolved as shift
WARNING: shift/reduce conflict for VAR in state 112 resolved as shift
WARNING: shift/reduce conflict for def in state 112 resolved as shift
WARNING: shift/reduce conflict for class in state 112 resolved as shift
WARNING: shift/reduce conflict for print in state 112 resolved as shift
WARNING: shift/reduce conflict for if in state 112 resolved as shift
WARNING: shift/reduce conflict for STRLIT in state 112 resolved as shift
WARNING: shift/reduce conflict for INTLIT in state 112 resolved as shift
WARNING: shift/reduce conflict for OPENPAR in state 112 resolved as shift
WARNING: shift/reduce conflict for CLOSECURLY in state 120 resolved as shift
WARNING: shift/reduce conflict for VAR in state 120 resolved as shift
WARNING: shift/reduce conflict for def in state 120 resolved as shift
WARNING: shift/reduce conflict for class in state 120 resolved as shift
WARNING: shift/reduce conflict for print in state 120 resolved as shift
WARNING: shift/reduce conflict for CLOSECURLY in state 120 resolved as shift
WARNING: shift/reduce conflict for VAR in state 120 resolved as shift
WARNING: shift/reduce conflict for def in state 120 resolved as shift
WARNING: shift/reduce conflict for class in state 120 resolved as shift
WARNING: shift/reduce conflict for print in state 120 resolved as shift
WARNING: shift/reduce conflict for if in state 120 resolved as shift
WARNING: shift/reduce conflict for STRLIT in state 120 resolved as shift
WARNING: shift/reduce conflict for INTLIT in state 120 resolved as shift
WARNING: shift/reduce conflict for OPENPAR in state 120 resolved as shift
WARNING: reduce/reduce conflict in state 8 resolved using rule (empty -> <empty>)
WARNING: rejected rule (statement_list -> statement) in state 8
WARNING: reduce/reduce conflict in state 23 resolved using rule (empty -> <empty>)
WARNING: rejected rule (statement_list -> statement) in state 23
WARNING: reduce/reduce conflict in state 24 resolved using rule (statement -> statement_list)
WARNING: rejected rule (statement_list -> statement statement_list) in state 24
WARNING: reduce/reduce conflict in state 71 resolved using rule (empty -> <empty>)
WARNING: rejected rule (statement_list -> statement) in state 71
WARNING: reduce/reduce conflict in state 88 resolved using rule (empty -> <empty>)
WARNING: rejected rule (statement_list -> statement) in state 88
WARNING: reduce/reduce conflict in state 103 resolved using rule (empty -> <empty>)
WARNING: rejected rule (statement_list -> statement) in state 103
WARNING: reduce/reduce conflict in state 120 resolved using rule (empty -> <empty>)
WARNING: rejected rule (statement_list -> statement) in state 120
WARNING: Rule (statement_list -> statement) is never reduced
WARNING: Rule (statement_list -> statement statement_list) is never reduced
