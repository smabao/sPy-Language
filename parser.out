Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    BOOLEAN
    CHRLIT
    CLOSEBRACE
    COMMA
    DBLLIT
    FLTLIT
    MULTI_COMMENT
    NOT
    OPENBRACE
    QUOTATION
    SINGLE_COMMENT
    UNDERSCORE
    break
    call
    do
    for
    is
    try
    while

Grammar

Rule 0     S' -> main_program
Rule 1     main_program -> start OPENCURLY statement CLOSECURLY end
Rule 2     statement -> empty
Rule 3     empty -> <empty>
Rule 4     statement -> statement_list
Rule 5     statement_list -> statement
Rule 6     statement_list -> statement statement_list
Rule 7     statement -> VAR ASSIGN expression TILDE
Rule 8     statement -> expression TILDE
Rule 9     statement -> def VAR OPENPAR parameter CLOSEPAR OPENCURLY statement CLOSECURLY end_def
Rule 10    parameter -> int VAR
Rule 11    parameter -> string VAR
Rule 12    statement -> class VAR OPENCURLY statement CLOSECURLY
Rule 13    statement -> VAR ASSIGN expression TILDE scan OPENPAR VAR CLOSEPAR TILDE
Rule 14    statement -> VAR ASSIGN STRLIT TILDE scan OPENPAR VAR CLOSEPAR TILDE
Rule 15    statement -> VAR ASSIGN expression TILDE return OPENPAR VAR CLOSEPAR TILDE
Rule 16    statement -> VAR ASSIGN STRLIT TILDE return OPENPAR VAR CLOSEPAR TILDE
Rule 17    statement -> print OPENPAR expression CLOSEPAR TILDE
Rule 18    statement -> print OPENPAR STRLIT CLOSEPAR TILDE
Rule 19    statement -> VAR ASSIGN expression TILDE print OPENPAR VAR CLOSEPAR TILDE
Rule 20    statement -> VAR ASSIGN STRLIT TILDE print OPENPAR VAR CLOSEPAR TILDE
Rule 21    statement -> if_statement
Rule 22    if_statement -> if OPENPAR boolean CLOSEPAR OPENCURLY statement CLOSECURLY
Rule 23    if_statement -> if OPENPAR boolean CLOSEPAR OPENCURLY statement CLOSECURLY else OPENCURLY statement CLOSECURLY
Rule 24    expression -> term
Rule 25    expression -> boolean
Rule 26    boolean -> expression GT term
Rule 27    boolean -> expression GEQ term
Rule 28    boolean -> expression LT term
Rule 29    boolean -> expression LEQ term
Rule 30    boolean -> expression EQ term
Rule 31    boolean -> expression NEQ term
Rule 32    boolean -> expression AND term
Rule 33    boolean -> expression OR term
Rule 34    expression -> expression PLUS term
Rule 35    expression -> expression MINUS term
Rule 36    term -> term MUL factor
Rule 37    term -> term DIV factor
Rule 38    term -> term MOD factor
Rule 39    term -> STRLIT
Rule 40    term -> factor
Rule 41    factor -> INTLIT
Rule 42    factor -> OPENPAR expression CLOSEPAR

Terminals, with rules where they appear

AND                  : 32
ASSIGN               : 7 13 14 15 16 19 20
BOOLEAN              : 
CHRLIT               : 
CLOSEBRACE           : 
CLOSECURLY           : 1 9 12 22 23 23
CLOSEPAR             : 9 13 14 15 16 17 18 19 20 22 23 42
COMMA                : 
DBLLIT               : 
DIV                  : 37
EQ                   : 30
FLTLIT               : 
GEQ                  : 27
GT                   : 26
INTLIT               : 41
LEQ                  : 29
LT                   : 28
MINUS                : 35
MOD                  : 38
MUL                  : 36
MULTI_COMMENT        : 
NEQ                  : 31
NOT                  : 
OPENBRACE            : 
OPENCURLY            : 1 9 12 22 23 23
OPENPAR              : 9 13 14 15 16 17 18 19 20 22 23 42
OR                   : 33
PLUS                 : 34
QUOTATION            : 
SINGLE_COMMENT       : 
STRLIT               : 14 16 18 20 39
TILDE                : 7 8 13 13 14 14 15 15 16 16 17 18 19 19 20 20
UNDERSCORE           : 
VAR                  : 7 9 10 11 12 13 13 14 14 15 15 16 16 19 19 20 20
break                : 
call                 : 
class                : 12
def                  : 9
do                   : 
else                 : 23
end                  : 1
end_def              : 9
error                : 
for                  : 
if                   : 22 23
int                  : 10
is                   : 
print                : 17 18 19 20
return               : 15 16
scan                 : 13 14
start                : 1
string               : 11
try                  : 
while                : 

Nonterminals, with rules where they appear

boolean              : 22 23 25
empty                : 2
expression           : 7 8 13 15 17 19 26 27 28 29 30 31 32 33 34 35 42
factor               : 36 37 38 40
if_statement         : 21
main_program         : 0
parameter            : 9
statement            : 1 5 6 9 12 22 23 23
statement_list       : 4 6
term                 : 24 26 27 28 29 30 31 32 33 34 35 36 37 38

Parsing method: LALR

state 0

    (0) S' -> . main_program
    (1) main_program -> . start OPENCURLY statement CLOSECURLY end

    start           shift and go to state 2

    main_program                   shift and go to state 1

state 1

    (0) S' -> main_program .



state 2

    (1) main_program -> start . OPENCURLY statement CLOSECURLY end

    OPENCURLY       shift and go to state 3


state 3

    (1) main_program -> start OPENCURLY . statement CLOSECURLY end
    (2) statement -> . empty
    (4) statement -> . statement_list
    (7) statement -> . VAR ASSIGN expression TILDE
    (8) statement -> . expression TILDE
    (9) statement -> . def VAR OPENPAR parameter CLOSEPAR OPENCURLY statement CLOSECURLY end_def
    (12) statement -> . class VAR OPENCURLY statement CLOSECURLY
    (13) statement -> . VAR ASSIGN expression TILDE scan OPENPAR VAR CLOSEPAR TILDE
    (14) statement -> . VAR ASSIGN STRLIT TILDE scan OPENPAR VAR CLOSEPAR TILDE
    (15) statement -> . VAR ASSIGN expression TILDE return OPENPAR VAR CLOSEPAR TILDE
    (16) statement -> . VAR ASSIGN STRLIT TILDE return OPENPAR VAR CLOSEPAR TILDE
    (17) statement -> . print OPENPAR expression CLOSEPAR TILDE
    (18) statement -> . print OPENPAR STRLIT CLOSEPAR TILDE
    (19) statement -> . VAR ASSIGN expression TILDE print OPENPAR VAR CLOSEPAR TILDE
    (20) statement -> . VAR ASSIGN STRLIT TILDE print OPENPAR VAR CLOSEPAR TILDE
    (21) statement -> . if_statement
    (3) empty -> .
    (5) statement_list -> . statement
    (6) statement_list -> . statement statement_list
    (24) expression -> . term
    (25) expression -> . boolean
    (34) expression -> . expression PLUS term
    (35) expression -> . expression MINUS term
    (22) if_statement -> . if OPENPAR boolean CLOSEPAR OPENCURLY statement CLOSECURLY
    (23) if_statement -> . if OPENPAR boolean CLOSEPAR OPENCURLY statement CLOSECURLY else OPENCURLY statement CLOSECURLY
    (36) term -> . term MUL factor
    (37) term -> . term DIV factor
    (38) term -> . term MOD factor
    (39) term -> . STRLIT
    (40) term -> . factor
    (26) boolean -> . expression GT term
    (27) boolean -> . expression GEQ term
    (28) boolean -> . expression LT term
    (29) boolean -> . expression LEQ term
    (30) boolean -> . expression EQ term
    (31) boolean -> . expression NEQ term
    (32) boolean -> . expression AND term
    (33) boolean -> . expression OR term
    (41) factor -> . INTLIT
    (42) factor -> . OPENPAR expression CLOSEPAR

  ! shift/reduce conflict for VAR resolved as shift
  ! shift/reduce conflict for def resolved as shift
  ! shift/reduce conflict for class resolved as shift
  ! shift/reduce conflict for print resolved as shift
  ! shift/reduce conflict for if resolved as shift
  ! shift/reduce conflict for STRLIT resolved as shift
  ! shift/reduce conflict for INTLIT resolved as shift
  ! shift/reduce conflict for OPENPAR resolved as shift
    VAR             shift and go to state 7
    def             shift and go to state 9
    class           shift and go to state 11
    print           shift and go to state 13
    CLOSECURLY      reduce using rule 3 (empty -> .)
    if              shift and go to state 17
    STRLIT          shift and go to state 12
    INTLIT          shift and go to state 19
    OPENPAR         shift and go to state 10

  ! VAR             [ reduce using rule 3 (empty -> .) ]
  ! def             [ reduce using rule 3 (empty -> .) ]
  ! class           [ reduce using rule 3 (empty -> .) ]
  ! print           [ reduce using rule 3 (empty -> .) ]
  ! if              [ reduce using rule 3 (empty -> .) ]
  ! STRLIT          [ reduce using rule 3 (empty -> .) ]
  ! INTLIT          [ reduce using rule 3 (empty -> .) ]
  ! OPENPAR         [ reduce using rule 3 (empty -> .) ]

    statement                      shift and go to state 4
    empty                          shift and go to state 5
    statement_list                 shift and go to state 6
    expression                     shift and go to state 8
    if_statement                   shift and go to state 14
    term                           shift and go to state 15
    boolean                        shift and go to state 16
    factor                         shift and go to state 18

state 4

    (1) main_program -> start OPENCURLY statement . CLOSECURLY end
    (5) statement_list -> statement .
    (6) statement_list -> statement . statement_list
    (5) statement_list -> . statement
    (6) statement_list -> . statement statement_list
    (2) statement -> . empty
    (4) statement -> . statement_list
    (7) statement -> . VAR ASSIGN expression TILDE
    (8) statement -> . expression TILDE
    (9) statement -> . def VAR OPENPAR parameter CLOSEPAR OPENCURLY statement CLOSECURLY end_def
    (12) statement -> . class VAR OPENCURLY statement CLOSECURLY
    (13) statement -> . VAR ASSIGN expression TILDE scan OPENPAR VAR CLOSEPAR TILDE
    (14) statement -> . VAR ASSIGN STRLIT TILDE scan OPENPAR VAR CLOSEPAR TILDE
    (15) statement -> . VAR ASSIGN expression TILDE return OPENPAR VAR CLOSEPAR TILDE
    (16) statement -> . VAR ASSIGN STRLIT TILDE return OPENPAR VAR CLOSEPAR TILDE
    (17) statement -> . print OPENPAR expression CLOSEPAR TILDE
    (18) statement -> . print OPENPAR STRLIT CLOSEPAR TILDE
    (19) statement -> . VAR ASSIGN expression TILDE print OPENPAR VAR CLOSEPAR TILDE
    (20) statement -> . VAR ASSIGN STRLIT TILDE print OPENPAR VAR CLOSEPAR TILDE
    (21) statement -> . if_statement
    (3) empty -> .
    (24) expression -> . term
    (25) expression -> . boolean
    (34) expression -> . expression PLUS term
    (35) expression -> . expression MINUS term
    (22) if_statement -> . if OPENPAR boolean CLOSEPAR OPENCURLY statement CLOSECURLY
    (23) if_statement -> . if OPENPAR boolean CLOSEPAR OPENCURLY statement CLOSECURLY else OPENCURLY statement CLOSECURLY
    (36) term -> . term MUL factor
    (37) term -> . term DIV factor
    (38) term -> . term MOD factor
    (39) term -> . STRLIT
    (40) term -> . factor
    (26) boolean -> . expression GT term
    (27) boolean -> . expression GEQ term
    (28) boolean -> . expression LT term
    (29) boolean -> . expression LEQ term
    (30) boolean -> . expression EQ term
    (31) boolean -> . expression NEQ term
    (32) boolean -> . expression AND term
    (33) boolean -> . expression OR term
    (41) factor -> . INTLIT
    (42) factor -> . OPENPAR expression CLOSEPAR

  ! shift/reduce conflict for CLOSECURLY resolved as shift
  ! shift/reduce conflict for VAR resolved as shift
  ! shift/reduce conflict for def resolved as shift
  ! shift/reduce conflict for class resolved as shift
  ! shift/reduce conflict for print resolved as shift
  ! shift/reduce conflict for CLOSECURLY resolved as shift
  ! shift/reduce conflict for VAR resolved as shift
  ! shift/reduce conflict for def resolved as shift
  ! shift/reduce conflict for class resolved as shift
  ! shift/reduce conflict for print resolved as shift
  ! reduce/reduce conflict for if resolved using rule 3 (empty -> .)
  ! reduce/reduce conflict for STRLIT resolved using rule 3 (empty -> .)
  ! reduce/reduce conflict for INTLIT resolved using rule 3 (empty -> .)
  ! reduce/reduce conflict for OPENPAR resolved using rule 3 (empty -> .)
  ! shift/reduce conflict for if resolved as shift
  ! shift/reduce conflict for STRLIT resolved as shift
  ! shift/reduce conflict for INTLIT resolved as shift
  ! shift/reduce conflict for OPENPAR resolved as shift
    CLOSECURLY      shift and go to state 21
    VAR             shift and go to state 7
    def             shift and go to state 9
    class           shift and go to state 11
    print           shift and go to state 13
    if              shift and go to state 17
    STRLIT          shift and go to state 12
    INTLIT          shift and go to state 19
    OPENPAR         shift and go to state 10

  ! CLOSECURLY      [ reduce using rule 5 (statement_list -> statement .) ]
  ! VAR             [ reduce using rule 5 (statement_list -> statement .) ]
  ! def             [ reduce using rule 5 (statement_list -> statement .) ]
  ! class           [ reduce using rule 5 (statement_list -> statement .) ]
  ! print           [ reduce using rule 5 (statement_list -> statement .) ]
  ! if              [ reduce using rule 5 (statement_list -> statement .) ]
  ! STRLIT          [ reduce using rule 5 (statement_list -> statement .) ]
  ! INTLIT          [ reduce using rule 5 (statement_list -> statement .) ]
  ! OPENPAR         [ reduce using rule 5 (statement_list -> statement .) ]
  ! CLOSECURLY      [ reduce using rule 3 (empty -> .) ]
  ! VAR             [ reduce using rule 3 (empty -> .) ]
  ! def             [ reduce using rule 3 (empty -> .) ]
  ! class           [ reduce using rule 3 (empty -> .) ]
  ! print           [ reduce using rule 3 (empty -> .) ]
  ! if              [ reduce using rule 3 (empty -> .) ]
  ! STRLIT          [ reduce using rule 3 (empty -> .) ]
  ! INTLIT          [ reduce using rule 3 (empty -> .) ]
  ! OPENPAR         [ reduce using rule 3 (empty -> .) ]

    statement                      shift and go to state 20
    statement_list                 shift and go to state 22
    empty                          shift and go to state 5
    expression                     shift and go to state 8
    if_statement                   shift and go to state 14
    term                           shift and go to state 15
    boolean                        shift and go to state 16
    factor                         shift and go to state 18

state 5

    (2) statement -> empty .

    CLOSECURLY      reduce using rule 2 (statement -> empty .)
    VAR             reduce using rule 2 (statement -> empty .)
    def             reduce using rule 2 (statement -> empty .)
    class           reduce using rule 2 (statement -> empty .)
    print           reduce using rule 2 (statement -> empty .)
    if              reduce using rule 2 (statement -> empty .)
    STRLIT          reduce using rule 2 (statement -> empty .)
    INTLIT          reduce using rule 2 (statement -> empty .)
    OPENPAR         reduce using rule 2 (statement -> empty .)


state 6

    (4) statement -> statement_list .

    CLOSECURLY      reduce using rule 4 (statement -> statement_list .)
    VAR             reduce using rule 4 (statement -> statement_list .)
    def             reduce using rule 4 (statement -> statement_list .)
    class           reduce using rule 4 (statement -> statement_list .)
    print           reduce using rule 4 (statement -> statement_list .)
    if              reduce using rule 4 (statement -> statement_list .)
    STRLIT          reduce using rule 4 (statement -> statement_list .)
    INTLIT          reduce using rule 4 (statement -> statement_list .)
    OPENPAR         reduce using rule 4 (statement -> statement_list .)


state 7

    (7) statement -> VAR . ASSIGN expression TILDE
    (13) statement -> VAR . ASSIGN expression TILDE scan OPENPAR VAR CLOSEPAR TILDE
    (14) statement -> VAR . ASSIGN STRLIT TILDE scan OPENPAR VAR CLOSEPAR TILDE
    (15) statement -> VAR . ASSIGN expression TILDE return OPENPAR VAR CLOSEPAR TILDE
    (16) statement -> VAR . ASSIGN STRLIT TILDE return OPENPAR VAR CLOSEPAR TILDE
    (19) statement -> VAR . ASSIGN expression TILDE print OPENPAR VAR CLOSEPAR TILDE
    (20) statement -> VAR . ASSIGN STRLIT TILDE print OPENPAR VAR CLOSEPAR TILDE

    ASSIGN          shift and go to state 23


state 8

    (8) statement -> expression . TILDE
    (34) expression -> expression . PLUS term
    (35) expression -> expression . MINUS term
    (26) boolean -> expression . GT term
    (27) boolean -> expression . GEQ term
    (28) boolean -> expression . LT term
    (29) boolean -> expression . LEQ term
    (30) boolean -> expression . EQ term
    (31) boolean -> expression . NEQ term
    (32) boolean -> expression . AND term
    (33) boolean -> expression . OR term

    TILDE           shift and go to state 24
    PLUS            shift and go to state 25
    MINUS           shift and go to state 26
    GT              shift and go to state 27
    GEQ             shift and go to state 28
    LT              shift and go to state 29
    LEQ             shift and go to state 30
    EQ              shift and go to state 31
    NEQ             shift and go to state 32
    AND             shift and go to state 33
    OR              shift and go to state 34


state 9

    (9) statement -> def . VAR OPENPAR parameter CLOSEPAR OPENCURLY statement CLOSECURLY end_def

    VAR             shift and go to state 35


state 10

    (42) factor -> OPENPAR . expression CLOSEPAR
    (24) expression -> . term
    (25) expression -> . boolean
    (34) expression -> . expression PLUS term
    (35) expression -> . expression MINUS term
    (36) term -> . term MUL factor
    (37) term -> . term DIV factor
    (38) term -> . term MOD factor
    (39) term -> . STRLIT
    (40) term -> . factor
    (26) boolean -> . expression GT term
    (27) boolean -> . expression GEQ term
    (28) boolean -> . expression LT term
    (29) boolean -> . expression LEQ term
    (30) boolean -> . expression EQ term
    (31) boolean -> . expression NEQ term
    (32) boolean -> . expression AND term
    (33) boolean -> . expression OR term
    (41) factor -> . INTLIT
    (42) factor -> . OPENPAR expression CLOSEPAR

    STRLIT          shift and go to state 12
    INTLIT          shift and go to state 19
    OPENPAR         shift and go to state 10

    expression                     shift and go to state 36
    term                           shift and go to state 15
    boolean                        shift and go to state 16
    factor                         shift and go to state 18

state 11

    (12) statement -> class . VAR OPENCURLY statement CLOSECURLY

    VAR             shift and go to state 37


state 12

    (39) term -> STRLIT .

    MUL             reduce using rule 39 (term -> STRLIT .)
    DIV             reduce using rule 39 (term -> STRLIT .)
    MOD             reduce using rule 39 (term -> STRLIT .)
    TILDE           reduce using rule 39 (term -> STRLIT .)
    PLUS            reduce using rule 39 (term -> STRLIT .)
    MINUS           reduce using rule 39 (term -> STRLIT .)
    GT              reduce using rule 39 (term -> STRLIT .)
    GEQ             reduce using rule 39 (term -> STRLIT .)
    LT              reduce using rule 39 (term -> STRLIT .)
    LEQ             reduce using rule 39 (term -> STRLIT .)
    EQ              reduce using rule 39 (term -> STRLIT .)
    NEQ             reduce using rule 39 (term -> STRLIT .)
    AND             reduce using rule 39 (term -> STRLIT .)
    OR              reduce using rule 39 (term -> STRLIT .)
    CLOSEPAR        reduce using rule 39 (term -> STRLIT .)


state 13

    (17) statement -> print . OPENPAR expression CLOSEPAR TILDE
    (18) statement -> print . OPENPAR STRLIT CLOSEPAR TILDE

    OPENPAR         shift and go to state 38


state 14

    (21) statement -> if_statement .

    CLOSECURLY      reduce using rule 21 (statement -> if_statement .)
    VAR             reduce using rule 21 (statement -> if_statement .)
    def             reduce using rule 21 (statement -> if_statement .)
    class           reduce using rule 21 (statement -> if_statement .)
    print           reduce using rule 21 (statement -> if_statement .)
    if              reduce using rule 21 (statement -> if_statement .)
    STRLIT          reduce using rule 21 (statement -> if_statement .)
    INTLIT          reduce using rule 21 (statement -> if_statement .)
    OPENPAR         reduce using rule 21 (statement -> if_statement .)


state 15

    (24) expression -> term .
    (36) term -> term . MUL factor
    (37) term -> term . DIV factor
    (38) term -> term . MOD factor

    TILDE           reduce using rule 24 (expression -> term .)
    PLUS            reduce using rule 24 (expression -> term .)
    MINUS           reduce using rule 24 (expression -> term .)
    GT              reduce using rule 24 (expression -> term .)
    GEQ             reduce using rule 24 (expression -> term .)
    LT              reduce using rule 24 (expression -> term .)
    LEQ             reduce using rule 24 (expression -> term .)
    EQ              reduce using rule 24 (expression -> term .)
    NEQ             reduce using rule 24 (expression -> term .)
    AND             reduce using rule 24 (expression -> term .)
    OR              reduce using rule 24 (expression -> term .)
    CLOSEPAR        reduce using rule 24 (expression -> term .)
    MUL             shift and go to state 39
    DIV             shift and go to state 40
    MOD             shift and go to state 41


state 16

    (25) expression -> boolean .

    TILDE           reduce using rule 25 (expression -> boolean .)
    PLUS            reduce using rule 25 (expression -> boolean .)
    MINUS           reduce using rule 25 (expression -> boolean .)
    GT              reduce using rule 25 (expression -> boolean .)
    GEQ             reduce using rule 25 (expression -> boolean .)
    LT              reduce using rule 25 (expression -> boolean .)
    LEQ             reduce using rule 25 (expression -> boolean .)
    EQ              reduce using rule 25 (expression -> boolean .)
    NEQ             reduce using rule 25 (expression -> boolean .)
    AND             reduce using rule 25 (expression -> boolean .)
    OR              reduce using rule 25 (expression -> boolean .)
    CLOSEPAR        reduce using rule 25 (expression -> boolean .)


state 17

    (22) if_statement -> if . OPENPAR boolean CLOSEPAR OPENCURLY statement CLOSECURLY
    (23) if_statement -> if . OPENPAR boolean CLOSEPAR OPENCURLY statement CLOSECURLY else OPENCURLY statement CLOSECURLY

    OPENPAR         shift and go to state 42


state 18

    (40) term -> factor .

    MUL             reduce using rule 40 (term -> factor .)
    DIV             reduce using rule 40 (term -> factor .)
    MOD             reduce using rule 40 (term -> factor .)
    TILDE           reduce using rule 40 (term -> factor .)
    PLUS            reduce using rule 40 (term -> factor .)
    MINUS           reduce using rule 40 (term -> factor .)
    GT              reduce using rule 40 (term -> factor .)
    GEQ             reduce using rule 40 (term -> factor .)
    LT              reduce using rule 40 (term -> factor .)
    LEQ             reduce using rule 40 (term -> factor .)
    EQ              reduce using rule 40 (term -> factor .)
    NEQ             reduce using rule 40 (term -> factor .)
    AND             reduce using rule 40 (term -> factor .)
    OR              reduce using rule 40 (term -> factor .)
    CLOSEPAR        reduce using rule 40 (term -> factor .)


state 19

    (41) factor -> INTLIT .

    MUL             reduce using rule 41 (factor -> INTLIT .)
    DIV             reduce using rule 41 (factor -> INTLIT .)
    MOD             reduce using rule 41 (factor -> INTLIT .)
    TILDE           reduce using rule 41 (factor -> INTLIT .)
    PLUS            reduce using rule 41 (factor -> INTLIT .)
    MINUS           reduce using rule 41 (factor -> INTLIT .)
    GT              reduce using rule 41 (factor -> INTLIT .)
    GEQ             reduce using rule 41 (factor -> INTLIT .)
    LT              reduce using rule 41 (factor -> INTLIT .)
    LEQ             reduce using rule 41 (factor -> INTLIT .)
    EQ              reduce using rule 41 (factor -> INTLIT .)
    NEQ             reduce using rule 41 (factor -> INTLIT .)
    AND             reduce using rule 41 (factor -> INTLIT .)
    OR              reduce using rule 41 (factor -> INTLIT .)
    CLOSEPAR        reduce using rule 41 (factor -> INTLIT .)


state 20

    (5) statement_list -> statement .
    (6) statement_list -> statement . statement_list
    (5) statement_list -> . statement
    (6) statement_list -> . statement statement_list
    (2) statement -> . empty
    (4) statement -> . statement_list
    (7) statement -> . VAR ASSIGN expression TILDE
    (8) statement -> . expression TILDE
    (9) statement -> . def VAR OPENPAR parameter CLOSEPAR OPENCURLY statement CLOSECURLY end_def
    (12) statement -> . class VAR OPENCURLY statement CLOSECURLY
    (13) statement -> . VAR ASSIGN expression TILDE scan OPENPAR VAR CLOSEPAR TILDE
    (14) statement -> . VAR ASSIGN STRLIT TILDE scan OPENPAR VAR CLOSEPAR TILDE
    (15) statement -> . VAR ASSIGN expression TILDE return OPENPAR VAR CLOSEPAR TILDE
    (16) statement -> . VAR ASSIGN STRLIT TILDE return OPENPAR VAR CLOSEPAR TILDE
    (17) statement -> . print OPENPAR expression CLOSEPAR TILDE
    (18) statement -> . print OPENPAR STRLIT CLOSEPAR TILDE
    (19) statement -> . VAR ASSIGN expression TILDE print OPENPAR VAR CLOSEPAR TILDE
    (20) statement -> . VAR ASSIGN STRLIT TILDE print OPENPAR VAR CLOSEPAR TILDE
    (21) statement -> . if_statement
    (3) empty -> .
    (24) expression -> . term
    (25) expression -> . boolean
    (34) expression -> . expression PLUS term
    (35) expression -> . expression MINUS term
    (22) if_statement -> . if OPENPAR boolean CLOSEPAR OPENCURLY statement CLOSECURLY
    (23) if_statement -> . if OPENPAR boolean CLOSEPAR OPENCURLY statement CLOSECURLY else OPENCURLY statement CLOSECURLY
    (36) term -> . term MUL factor
    (37) term -> . term DIV factor
    (38) term -> . term MOD factor
    (39) term -> . STRLIT
    (40) term -> . factor
    (26) boolean -> . expression GT term
    (27) boolean -> . expression GEQ term
    (28) boolean -> . expression LT term
    (29) boolean -> . expression LEQ term
    (30) boolean -> . expression EQ term
    (31) boolean -> . expression NEQ term
    (32) boolean -> . expression AND term
    (33) boolean -> . expression OR term
    (41) factor -> . INTLIT
    (42) factor -> . OPENPAR expression CLOSEPAR

  ! shift/reduce conflict for VAR resolved as shift
  ! shift/reduce conflict for def resolved as shift
  ! shift/reduce conflict for class resolved as shift
  ! shift/reduce conflict for print resolved as shift
  ! reduce/reduce conflict for CLOSECURLY resolved using rule 3 (empty -> .)
  ! shift/reduce conflict for VAR resolved as shift
  ! shift/reduce conflict for def resolved as shift
  ! shift/reduce conflict for class resolved as shift
  ! shift/reduce conflict for print resolved as shift
  ! reduce/reduce conflict for if resolved using rule 3 (empty -> .)
  ! reduce/reduce conflict for STRLIT resolved using rule 3 (empty -> .)
  ! reduce/reduce conflict for INTLIT resolved using rule 3 (empty -> .)
  ! reduce/reduce conflict for OPENPAR resolved using rule 3 (empty -> .)
  ! shift/reduce conflict for if resolved as shift
  ! shift/reduce conflict for STRLIT resolved as shift
  ! shift/reduce conflict for INTLIT resolved as shift
  ! shift/reduce conflict for OPENPAR resolved as shift
    VAR             shift and go to state 7
    def             shift and go to state 9
    class           shift and go to state 11
    print           shift and go to state 13
    CLOSECURLY      reduce using rule 3 (empty -> .)
    if              shift and go to state 17
    STRLIT          shift and go to state 12
    INTLIT          shift and go to state 19
    OPENPAR         shift and go to state 10

  ! CLOSECURLY      [ reduce using rule 5 (statement_list -> statement .) ]
  ! VAR             [ reduce using rule 5 (statement_list -> statement .) ]
  ! def             [ reduce using rule 5 (statement_list -> statement .) ]
  ! class           [ reduce using rule 5 (statement_list -> statement .) ]
  ! print           [ reduce using rule 5 (statement_list -> statement .) ]
  ! if              [ reduce using rule 5 (statement_list -> statement .) ]
  ! STRLIT          [ reduce using rule 5 (statement_list -> statement .) ]
  ! INTLIT          [ reduce using rule 5 (statement_list -> statement .) ]
  ! OPENPAR         [ reduce using rule 5 (statement_list -> statement .) ]
  ! VAR             [ reduce using rule 3 (empty -> .) ]
  ! def             [ reduce using rule 3 (empty -> .) ]
  ! class           [ reduce using rule 3 (empty -> .) ]
  ! print           [ reduce using rule 3 (empty -> .) ]
  ! if              [ reduce using rule 3 (empty -> .) ]
  ! STRLIT          [ reduce using rule 3 (empty -> .) ]
  ! INTLIT          [ reduce using rule 3 (empty -> .) ]
  ! OPENPAR         [ reduce using rule 3 (empty -> .) ]

    statement                      shift and go to state 20
    statement_list                 shift and go to state 22
    empty                          shift and go to state 5
    expression                     shift and go to state 8
    if_statement                   shift and go to state 14
    term                           shift and go to state 15
    boolean                        shift and go to state 16
    factor                         shift and go to state 18

state 21

    (1) main_program -> start OPENCURLY statement CLOSECURLY . end

    end             shift and go to state 43


state 22

    (6) statement_list -> statement statement_list .
    (4) statement -> statement_list .

  ! reduce/reduce conflict for CLOSECURLY resolved using rule 4 (statement -> statement_list .)
  ! reduce/reduce conflict for VAR resolved using rule 4 (statement -> statement_list .)
  ! reduce/reduce conflict for def resolved using rule 4 (statement -> statement_list .)
  ! reduce/reduce conflict for class resolved using rule 4 (statement -> statement_list .)
  ! reduce/reduce conflict for print resolved using rule 4 (statement -> statement_list .)
  ! reduce/reduce conflict for if resolved using rule 4 (statement -> statement_list .)
  ! reduce/reduce conflict for STRLIT resolved using rule 4 (statement -> statement_list .)
  ! reduce/reduce conflict for INTLIT resolved using rule 4 (statement -> statement_list .)
  ! reduce/reduce conflict for OPENPAR resolved using rule 4 (statement -> statement_list .)
    CLOSECURLY      reduce using rule 4 (statement -> statement_list .)
    VAR             reduce using rule 4 (statement -> statement_list .)
    def             reduce using rule 4 (statement -> statement_list .)
    class           reduce using rule 4 (statement -> statement_list .)
    print           reduce using rule 4 (statement -> statement_list .)
    if              reduce using rule 4 (statement -> statement_list .)
    STRLIT          reduce using rule 4 (statement -> statement_list .)
    INTLIT          reduce using rule 4 (statement -> statement_list .)
    OPENPAR         reduce using rule 4 (statement -> statement_list .)

  ! CLOSECURLY      [ reduce using rule 6 (statement_list -> statement statement_list .) ]
  ! VAR             [ reduce using rule 6 (statement_list -> statement statement_list .) ]
  ! def             [ reduce using rule 6 (statement_list -> statement statement_list .) ]
  ! class           [ reduce using rule 6 (statement_list -> statement statement_list .) ]
  ! print           [ reduce using rule 6 (statement_list -> statement statement_list .) ]
  ! if              [ reduce using rule 6 (statement_list -> statement statement_list .) ]
  ! STRLIT          [ reduce using rule 6 (statement_list -> statement statement_list .) ]
  ! INTLIT          [ reduce using rule 6 (statement_list -> statement statement_list .) ]
  ! OPENPAR         [ reduce using rule 6 (statement_list -> statement statement_list .) ]


state 23

    (7) statement -> VAR ASSIGN . expression TILDE
    (13) statement -> VAR ASSIGN . expression TILDE scan OPENPAR VAR CLOSEPAR TILDE
    (14) statement -> VAR ASSIGN . STRLIT TILDE scan OPENPAR VAR CLOSEPAR TILDE
    (15) statement -> VAR ASSIGN . expression TILDE return OPENPAR VAR CLOSEPAR TILDE
    (16) statement -> VAR ASSIGN . STRLIT TILDE return OPENPAR VAR CLOSEPAR TILDE
    (19) statement -> VAR ASSIGN . expression TILDE print OPENPAR VAR CLOSEPAR TILDE
    (20) statement -> VAR ASSIGN . STRLIT TILDE print OPENPAR VAR CLOSEPAR TILDE
    (24) expression -> . term
    (25) expression -> . boolean
    (34) expression -> . expression PLUS term
    (35) expression -> . expression MINUS term
    (36) term -> . term MUL factor
    (37) term -> . term DIV factor
    (38) term -> . term MOD factor
    (39) term -> . STRLIT
    (40) term -> . factor
    (26) boolean -> . expression GT term
    (27) boolean -> . expression GEQ term
    (28) boolean -> . expression LT term
    (29) boolean -> . expression LEQ term
    (30) boolean -> . expression EQ term
    (31) boolean -> . expression NEQ term
    (32) boolean -> . expression AND term
    (33) boolean -> . expression OR term
    (41) factor -> . INTLIT
    (42) factor -> . OPENPAR expression CLOSEPAR

    STRLIT          shift and go to state 45
    INTLIT          shift and go to state 19
    OPENPAR         shift and go to state 10

    expression                     shift and go to state 44
    term                           shift and go to state 15
    boolean                        shift and go to state 16
    factor                         shift and go to state 18

state 24

    (8) statement -> expression TILDE .

    CLOSECURLY      reduce using rule 8 (statement -> expression TILDE .)
    VAR             reduce using rule 8 (statement -> expression TILDE .)
    def             reduce using rule 8 (statement -> expression TILDE .)
    class           reduce using rule 8 (statement -> expression TILDE .)
    print           reduce using rule 8 (statement -> expression TILDE .)
    if              reduce using rule 8 (statement -> expression TILDE .)
    STRLIT          reduce using rule 8 (statement -> expression TILDE .)
    INTLIT          reduce using rule 8 (statement -> expression TILDE .)
    OPENPAR         reduce using rule 8 (statement -> expression TILDE .)


state 25

    (34) expression -> expression PLUS . term
    (36) term -> . term MUL factor
    (37) term -> . term DIV factor
    (38) term -> . term MOD factor
    (39) term -> . STRLIT
    (40) term -> . factor
    (41) factor -> . INTLIT
    (42) factor -> . OPENPAR expression CLOSEPAR

    STRLIT          shift and go to state 12
    INTLIT          shift and go to state 19
    OPENPAR         shift and go to state 10

    term                           shift and go to state 46
    factor                         shift and go to state 18

state 26

    (35) expression -> expression MINUS . term
    (36) term -> . term MUL factor
    (37) term -> . term DIV factor
    (38) term -> . term MOD factor
    (39) term -> . STRLIT
    (40) term -> . factor
    (41) factor -> . INTLIT
    (42) factor -> . OPENPAR expression CLOSEPAR

    STRLIT          shift and go to state 12
    INTLIT          shift and go to state 19
    OPENPAR         shift and go to state 10

    term                           shift and go to state 47
    factor                         shift and go to state 18

state 27

    (26) boolean -> expression GT . term
    (36) term -> . term MUL factor
    (37) term -> . term DIV factor
    (38) term -> . term MOD factor
    (39) term -> . STRLIT
    (40) term -> . factor
    (41) factor -> . INTLIT
    (42) factor -> . OPENPAR expression CLOSEPAR

    STRLIT          shift and go to state 12
    INTLIT          shift and go to state 19
    OPENPAR         shift and go to state 10

    term                           shift and go to state 48
    factor                         shift and go to state 18

state 28

    (27) boolean -> expression GEQ . term
    (36) term -> . term MUL factor
    (37) term -> . term DIV factor
    (38) term -> . term MOD factor
    (39) term -> . STRLIT
    (40) term -> . factor
    (41) factor -> . INTLIT
    (42) factor -> . OPENPAR expression CLOSEPAR

    STRLIT          shift and go to state 12
    INTLIT          shift and go to state 19
    OPENPAR         shift and go to state 10

    term                           shift and go to state 49
    factor                         shift and go to state 18

state 29

    (28) boolean -> expression LT . term
    (36) term -> . term MUL factor
    (37) term -> . term DIV factor
    (38) term -> . term MOD factor
    (39) term -> . STRLIT
    (40) term -> . factor
    (41) factor -> . INTLIT
    (42) factor -> . OPENPAR expression CLOSEPAR

    STRLIT          shift and go to state 12
    INTLIT          shift and go to state 19
    OPENPAR         shift and go to state 10

    term                           shift and go to state 50
    factor                         shift and go to state 18

state 30

    (29) boolean -> expression LEQ . term
    (36) term -> . term MUL factor
    (37) term -> . term DIV factor
    (38) term -> . term MOD factor
    (39) term -> . STRLIT
    (40) term -> . factor
    (41) factor -> . INTLIT
    (42) factor -> . OPENPAR expression CLOSEPAR

    STRLIT          shift and go to state 12
    INTLIT          shift and go to state 19
    OPENPAR         shift and go to state 10

    term                           shift and go to state 51
    factor                         shift and go to state 18

state 31

    (30) boolean -> expression EQ . term
    (36) term -> . term MUL factor
    (37) term -> . term DIV factor
    (38) term -> . term MOD factor
    (39) term -> . STRLIT
    (40) term -> . factor
    (41) factor -> . INTLIT
    (42) factor -> . OPENPAR expression CLOSEPAR

    STRLIT          shift and go to state 12
    INTLIT          shift and go to state 19
    OPENPAR         shift and go to state 10

    term                           shift and go to state 52
    factor                         shift and go to state 18

state 32

    (31) boolean -> expression NEQ . term
    (36) term -> . term MUL factor
    (37) term -> . term DIV factor
    (38) term -> . term MOD factor
    (39) term -> . STRLIT
    (40) term -> . factor
    (41) factor -> . INTLIT
    (42) factor -> . OPENPAR expression CLOSEPAR

    STRLIT          shift and go to state 12
    INTLIT          shift and go to state 19
    OPENPAR         shift and go to state 10

    term                           shift and go to state 53
    factor                         shift and go to state 18

state 33

    (32) boolean -> expression AND . term
    (36) term -> . term MUL factor
    (37) term -> . term DIV factor
    (38) term -> . term MOD factor
    (39) term -> . STRLIT
    (40) term -> . factor
    (41) factor -> . INTLIT
    (42) factor -> . OPENPAR expression CLOSEPAR

    STRLIT          shift and go to state 12
    INTLIT          shift and go to state 19
    OPENPAR         shift and go to state 10

    term                           shift and go to state 54
    factor                         shift and go to state 18

state 34

    (33) boolean -> expression OR . term
    (36) term -> . term MUL factor
    (37) term -> . term DIV factor
    (38) term -> . term MOD factor
    (39) term -> . STRLIT
    (40) term -> . factor
    (41) factor -> . INTLIT
    (42) factor -> . OPENPAR expression CLOSEPAR

    STRLIT          shift and go to state 12
    INTLIT          shift and go to state 19
    OPENPAR         shift and go to state 10

    term                           shift and go to state 55
    factor                         shift and go to state 18

state 35

    (9) statement -> def VAR . OPENPAR parameter CLOSEPAR OPENCURLY statement CLOSECURLY end_def

    OPENPAR         shift and go to state 56


state 36

    (42) factor -> OPENPAR expression . CLOSEPAR
    (34) expression -> expression . PLUS term
    (35) expression -> expression . MINUS term
    (26) boolean -> expression . GT term
    (27) boolean -> expression . GEQ term
    (28) boolean -> expression . LT term
    (29) boolean -> expression . LEQ term
    (30) boolean -> expression . EQ term
    (31) boolean -> expression . NEQ term
    (32) boolean -> expression . AND term
    (33) boolean -> expression . OR term

    CLOSEPAR        shift and go to state 57
    PLUS            shift and go to state 25
    MINUS           shift and go to state 26
    GT              shift and go to state 27
    GEQ             shift and go to state 28
    LT              shift and go to state 29
    LEQ             shift and go to state 30
    EQ              shift and go to state 31
    NEQ             shift and go to state 32
    AND             shift and go to state 33
    OR              shift and go to state 34


state 37

    (12) statement -> class VAR . OPENCURLY statement CLOSECURLY

    OPENCURLY       shift and go to state 58


state 38

    (17) statement -> print OPENPAR . expression CLOSEPAR TILDE
    (18) statement -> print OPENPAR . STRLIT CLOSEPAR TILDE
    (24) expression -> . term
    (25) expression -> . boolean
    (34) expression -> . expression PLUS term
    (35) expression -> . expression MINUS term
    (36) term -> . term MUL factor
    (37) term -> . term DIV factor
    (38) term -> . term MOD factor
    (39) term -> . STRLIT
    (40) term -> . factor
    (26) boolean -> . expression GT term
    (27) boolean -> . expression GEQ term
    (28) boolean -> . expression LT term
    (29) boolean -> . expression LEQ term
    (30) boolean -> . expression EQ term
    (31) boolean -> . expression NEQ term
    (32) boolean -> . expression AND term
    (33) boolean -> . expression OR term
    (41) factor -> . INTLIT
    (42) factor -> . OPENPAR expression CLOSEPAR

    STRLIT          shift and go to state 60
    INTLIT          shift and go to state 19
    OPENPAR         shift and go to state 10

    expression                     shift and go to state 59
    term                           shift and go to state 15
    boolean                        shift and go to state 16
    factor                         shift and go to state 18

state 39

    (36) term -> term MUL . factor
    (41) factor -> . INTLIT
    (42) factor -> . OPENPAR expression CLOSEPAR

    INTLIT          shift and go to state 19
    OPENPAR         shift and go to state 10

    factor                         shift and go to state 61

state 40

    (37) term -> term DIV . factor
    (41) factor -> . INTLIT
    (42) factor -> . OPENPAR expression CLOSEPAR

    INTLIT          shift and go to state 19
    OPENPAR         shift and go to state 10

    factor                         shift and go to state 62

state 41

    (38) term -> term MOD . factor
    (41) factor -> . INTLIT
    (42) factor -> . OPENPAR expression CLOSEPAR

    INTLIT          shift and go to state 19
    OPENPAR         shift and go to state 10

    factor                         shift and go to state 63

state 42

    (22) if_statement -> if OPENPAR . boolean CLOSEPAR OPENCURLY statement CLOSECURLY
    (23) if_statement -> if OPENPAR . boolean CLOSEPAR OPENCURLY statement CLOSECURLY else OPENCURLY statement CLOSECURLY
    (26) boolean -> . expression GT term
    (27) boolean -> . expression GEQ term
    (28) boolean -> . expression LT term
    (29) boolean -> . expression LEQ term
    (30) boolean -> . expression EQ term
    (31) boolean -> . expression NEQ term
    (32) boolean -> . expression AND term
    (33) boolean -> . expression OR term
    (24) expression -> . term
    (25) expression -> . boolean
    (34) expression -> . expression PLUS term
    (35) expression -> . expression MINUS term
    (36) term -> . term MUL factor
    (37) term -> . term DIV factor
    (38) term -> . term MOD factor
    (39) term -> . STRLIT
    (40) term -> . factor
    (41) factor -> . INTLIT
    (42) factor -> . OPENPAR expression CLOSEPAR

    STRLIT          shift and go to state 12
    INTLIT          shift and go to state 19
    OPENPAR         shift and go to state 10

    boolean                        shift and go to state 64
    expression                     shift and go to state 65
    term                           shift and go to state 15
    factor                         shift and go to state 18

state 43

    (1) main_program -> start OPENCURLY statement CLOSECURLY end .

    $end            reduce using rule 1 (main_program -> start OPENCURLY statement CLOSECURLY end .)


state 44

    (7) statement -> VAR ASSIGN expression . TILDE
    (13) statement -> VAR ASSIGN expression . TILDE scan OPENPAR VAR CLOSEPAR TILDE
    (15) statement -> VAR ASSIGN expression . TILDE return OPENPAR VAR CLOSEPAR TILDE
    (19) statement -> VAR ASSIGN expression . TILDE print OPENPAR VAR CLOSEPAR TILDE
    (34) expression -> expression . PLUS term
    (35) expression -> expression . MINUS term
    (26) boolean -> expression . GT term
    (27) boolean -> expression . GEQ term
    (28) boolean -> expression . LT term
    (29) boolean -> expression . LEQ term
    (30) boolean -> expression . EQ term
    (31) boolean -> expression . NEQ term
    (32) boolean -> expression . AND term
    (33) boolean -> expression . OR term

    TILDE           shift and go to state 66
    PLUS            shift and go to state 25
    MINUS           shift and go to state 26
    GT              shift and go to state 27
    GEQ             shift and go to state 28
    LT              shift and go to state 29
    LEQ             shift and go to state 30
    EQ              shift and go to state 31
    NEQ             shift and go to state 32
    AND             shift and go to state 33
    OR              shift and go to state 34


state 45

    (14) statement -> VAR ASSIGN STRLIT . TILDE scan OPENPAR VAR CLOSEPAR TILDE
    (16) statement -> VAR ASSIGN STRLIT . TILDE return OPENPAR VAR CLOSEPAR TILDE
    (20) statement -> VAR ASSIGN STRLIT . TILDE print OPENPAR VAR CLOSEPAR TILDE
    (39) term -> STRLIT .

  ! shift/reduce conflict for TILDE resolved as shift
    TILDE           shift and go to state 67
    MUL             reduce using rule 39 (term -> STRLIT .)
    DIV             reduce using rule 39 (term -> STRLIT .)
    MOD             reduce using rule 39 (term -> STRLIT .)
    PLUS            reduce using rule 39 (term -> STRLIT .)
    MINUS           reduce using rule 39 (term -> STRLIT .)
    GT              reduce using rule 39 (term -> STRLIT .)
    GEQ             reduce using rule 39 (term -> STRLIT .)
    LT              reduce using rule 39 (term -> STRLIT .)
    LEQ             reduce using rule 39 (term -> STRLIT .)
    EQ              reduce using rule 39 (term -> STRLIT .)
    NEQ             reduce using rule 39 (term -> STRLIT .)
    AND             reduce using rule 39 (term -> STRLIT .)
    OR              reduce using rule 39 (term -> STRLIT .)

  ! TILDE           [ reduce using rule 39 (term -> STRLIT .) ]


state 46

    (34) expression -> expression PLUS term .
    (36) term -> term . MUL factor
    (37) term -> term . DIV factor
    (38) term -> term . MOD factor

    TILDE           reduce using rule 34 (expression -> expression PLUS term .)
    PLUS            reduce using rule 34 (expression -> expression PLUS term .)
    MINUS           reduce using rule 34 (expression -> expression PLUS term .)
    GT              reduce using rule 34 (expression -> expression PLUS term .)
    GEQ             reduce using rule 34 (expression -> expression PLUS term .)
    LT              reduce using rule 34 (expression -> expression PLUS term .)
    LEQ             reduce using rule 34 (expression -> expression PLUS term .)
    EQ              reduce using rule 34 (expression -> expression PLUS term .)
    NEQ             reduce using rule 34 (expression -> expression PLUS term .)
    AND             reduce using rule 34 (expression -> expression PLUS term .)
    OR              reduce using rule 34 (expression -> expression PLUS term .)
    CLOSEPAR        reduce using rule 34 (expression -> expression PLUS term .)
    MUL             shift and go to state 39
    DIV             shift and go to state 40
    MOD             shift and go to state 41


state 47

    (35) expression -> expression MINUS term .
    (36) term -> term . MUL factor
    (37) term -> term . DIV factor
    (38) term -> term . MOD factor

    TILDE           reduce using rule 35 (expression -> expression MINUS term .)
    PLUS            reduce using rule 35 (expression -> expression MINUS term .)
    MINUS           reduce using rule 35 (expression -> expression MINUS term .)
    GT              reduce using rule 35 (expression -> expression MINUS term .)
    GEQ             reduce using rule 35 (expression -> expression MINUS term .)
    LT              reduce using rule 35 (expression -> expression MINUS term .)
    LEQ             reduce using rule 35 (expression -> expression MINUS term .)
    EQ              reduce using rule 35 (expression -> expression MINUS term .)
    NEQ             reduce using rule 35 (expression -> expression MINUS term .)
    AND             reduce using rule 35 (expression -> expression MINUS term .)
    OR              reduce using rule 35 (expression -> expression MINUS term .)
    CLOSEPAR        reduce using rule 35 (expression -> expression MINUS term .)
    MUL             shift and go to state 39
    DIV             shift and go to state 40
    MOD             shift and go to state 41


state 48

    (26) boolean -> expression GT term .
    (36) term -> term . MUL factor
    (37) term -> term . DIV factor
    (38) term -> term . MOD factor

    TILDE           reduce using rule 26 (boolean -> expression GT term .)
    PLUS            reduce using rule 26 (boolean -> expression GT term .)
    MINUS           reduce using rule 26 (boolean -> expression GT term .)
    GT              reduce using rule 26 (boolean -> expression GT term .)
    GEQ             reduce using rule 26 (boolean -> expression GT term .)
    LT              reduce using rule 26 (boolean -> expression GT term .)
    LEQ             reduce using rule 26 (boolean -> expression GT term .)
    EQ              reduce using rule 26 (boolean -> expression GT term .)
    NEQ             reduce using rule 26 (boolean -> expression GT term .)
    AND             reduce using rule 26 (boolean -> expression GT term .)
    OR              reduce using rule 26 (boolean -> expression GT term .)
    CLOSEPAR        reduce using rule 26 (boolean -> expression GT term .)
    MUL             shift and go to state 39
    DIV             shift and go to state 40
    MOD             shift and go to state 41


state 49

    (27) boolean -> expression GEQ term .
    (36) term -> term . MUL factor
    (37) term -> term . DIV factor
    (38) term -> term . MOD factor

    TILDE           reduce using rule 27 (boolean -> expression GEQ term .)
    PLUS            reduce using rule 27 (boolean -> expression GEQ term .)
    MINUS           reduce using rule 27 (boolean -> expression GEQ term .)
    GT              reduce using rule 27 (boolean -> expression GEQ term .)
    GEQ             reduce using rule 27 (boolean -> expression GEQ term .)
    LT              reduce using rule 27 (boolean -> expression GEQ term .)
    LEQ             reduce using rule 27 (boolean -> expression GEQ term .)
    EQ              reduce using rule 27 (boolean -> expression GEQ term .)
    NEQ             reduce using rule 27 (boolean -> expression GEQ term .)
    AND             reduce using rule 27 (boolean -> expression GEQ term .)
    OR              reduce using rule 27 (boolean -> expression GEQ term .)
    CLOSEPAR        reduce using rule 27 (boolean -> expression GEQ term .)
    MUL             shift and go to state 39
    DIV             shift and go to state 40
    MOD             shift and go to state 41


state 50

    (28) boolean -> expression LT term .
    (36) term -> term . MUL factor
    (37) term -> term . DIV factor
    (38) term -> term . MOD factor

    TILDE           reduce using rule 28 (boolean -> expression LT term .)
    PLUS            reduce using rule 28 (boolean -> expression LT term .)
    MINUS           reduce using rule 28 (boolean -> expression LT term .)
    GT              reduce using rule 28 (boolean -> expression LT term .)
    GEQ             reduce using rule 28 (boolean -> expression LT term .)
    LT              reduce using rule 28 (boolean -> expression LT term .)
    LEQ             reduce using rule 28 (boolean -> expression LT term .)
    EQ              reduce using rule 28 (boolean -> expression LT term .)
    NEQ             reduce using rule 28 (boolean -> expression LT term .)
    AND             reduce using rule 28 (boolean -> expression LT term .)
    OR              reduce using rule 28 (boolean -> expression LT term .)
    CLOSEPAR        reduce using rule 28 (boolean -> expression LT term .)
    MUL             shift and go to state 39
    DIV             shift and go to state 40
    MOD             shift and go to state 41


state 51

    (29) boolean -> expression LEQ term .
    (36) term -> term . MUL factor
    (37) term -> term . DIV factor
    (38) term -> term . MOD factor

    TILDE           reduce using rule 29 (boolean -> expression LEQ term .)
    PLUS            reduce using rule 29 (boolean -> expression LEQ term .)
    MINUS           reduce using rule 29 (boolean -> expression LEQ term .)
    GT              reduce using rule 29 (boolean -> expression LEQ term .)
    GEQ             reduce using rule 29 (boolean -> expression LEQ term .)
    LT              reduce using rule 29 (boolean -> expression LEQ term .)
    LEQ             reduce using rule 29 (boolean -> expression LEQ term .)
    EQ              reduce using rule 29 (boolean -> expression LEQ term .)
    NEQ             reduce using rule 29 (boolean -> expression LEQ term .)
    AND             reduce using rule 29 (boolean -> expression LEQ term .)
    OR              reduce using rule 29 (boolean -> expression LEQ term .)
    CLOSEPAR        reduce using rule 29 (boolean -> expression LEQ term .)
    MUL             shift and go to state 39
    DIV             shift and go to state 40
    MOD             shift and go to state 41


state 52

    (30) boolean -> expression EQ term .
    (36) term -> term . MUL factor
    (37) term -> term . DIV factor
    (38) term -> term . MOD factor

    TILDE           reduce using rule 30 (boolean -> expression EQ term .)
    PLUS            reduce using rule 30 (boolean -> expression EQ term .)
    MINUS           reduce using rule 30 (boolean -> expression EQ term .)
    GT              reduce using rule 30 (boolean -> expression EQ term .)
    GEQ             reduce using rule 30 (boolean -> expression EQ term .)
    LT              reduce using rule 30 (boolean -> expression EQ term .)
    LEQ             reduce using rule 30 (boolean -> expression EQ term .)
    EQ              reduce using rule 30 (boolean -> expression EQ term .)
    NEQ             reduce using rule 30 (boolean -> expression EQ term .)
    AND             reduce using rule 30 (boolean -> expression EQ term .)
    OR              reduce using rule 30 (boolean -> expression EQ term .)
    CLOSEPAR        reduce using rule 30 (boolean -> expression EQ term .)
    MUL             shift and go to state 39
    DIV             shift and go to state 40
    MOD             shift and go to state 41


state 53

    (31) boolean -> expression NEQ term .
    (36) term -> term . MUL factor
    (37) term -> term . DIV factor
    (38) term -> term . MOD factor

    TILDE           reduce using rule 31 (boolean -> expression NEQ term .)
    PLUS            reduce using rule 31 (boolean -> expression NEQ term .)
    MINUS           reduce using rule 31 (boolean -> expression NEQ term .)
    GT              reduce using rule 31 (boolean -> expression NEQ term .)
    GEQ             reduce using rule 31 (boolean -> expression NEQ term .)
    LT              reduce using rule 31 (boolean -> expression NEQ term .)
    LEQ             reduce using rule 31 (boolean -> expression NEQ term .)
    EQ              reduce using rule 31 (boolean -> expression NEQ term .)
    NEQ             reduce using rule 31 (boolean -> expression NEQ term .)
    AND             reduce using rule 31 (boolean -> expression NEQ term .)
    OR              reduce using rule 31 (boolean -> expression NEQ term .)
    CLOSEPAR        reduce using rule 31 (boolean -> expression NEQ term .)
    MUL             shift and go to state 39
    DIV             shift and go to state 40
    MOD             shift and go to state 41


state 54

    (32) boolean -> expression AND term .
    (36) term -> term . MUL factor
    (37) term -> term . DIV factor
    (38) term -> term . MOD factor

    TILDE           reduce using rule 32 (boolean -> expression AND term .)
    PLUS            reduce using rule 32 (boolean -> expression AND term .)
    MINUS           reduce using rule 32 (boolean -> expression AND term .)
    GT              reduce using rule 32 (boolean -> expression AND term .)
    GEQ             reduce using rule 32 (boolean -> expression AND term .)
    LT              reduce using rule 32 (boolean -> expression AND term .)
    LEQ             reduce using rule 32 (boolean -> expression AND term .)
    EQ              reduce using rule 32 (boolean -> expression AND term .)
    NEQ             reduce using rule 32 (boolean -> expression AND term .)
    AND             reduce using rule 32 (boolean -> expression AND term .)
    OR              reduce using rule 32 (boolean -> expression AND term .)
    CLOSEPAR        reduce using rule 32 (boolean -> expression AND term .)
    MUL             shift and go to state 39
    DIV             shift and go to state 40
    MOD             shift and go to state 41


state 55

    (33) boolean -> expression OR term .
    (36) term -> term . MUL factor
    (37) term -> term . DIV factor
    (38) term -> term . MOD factor

    TILDE           reduce using rule 33 (boolean -> expression OR term .)
    PLUS            reduce using rule 33 (boolean -> expression OR term .)
    MINUS           reduce using rule 33 (boolean -> expression OR term .)
    GT              reduce using rule 33 (boolean -> expression OR term .)
    GEQ             reduce using rule 33 (boolean -> expression OR term .)
    LT              reduce using rule 33 (boolean -> expression OR term .)
    LEQ             reduce using rule 33 (boolean -> expression OR term .)
    EQ              reduce using rule 33 (boolean -> expression OR term .)
    NEQ             reduce using rule 33 (boolean -> expression OR term .)
    AND             reduce using rule 33 (boolean -> expression OR term .)
    OR              reduce using rule 33 (boolean -> expression OR term .)
    CLOSEPAR        reduce using rule 33 (boolean -> expression OR term .)
    MUL             shift and go to state 39
    DIV             shift and go to state 40
    MOD             shift and go to state 41


state 56

    (9) statement -> def VAR OPENPAR . parameter CLOSEPAR OPENCURLY statement CLOSECURLY end_def
    (10) parameter -> . int VAR
    (11) parameter -> . string VAR

    int             shift and go to state 69
    string          shift and go to state 70

    parameter                      shift and go to state 68

state 57

    (42) factor -> OPENPAR expression CLOSEPAR .

    MUL             reduce using rule 42 (factor -> OPENPAR expression CLOSEPAR .)
    DIV             reduce using rule 42 (factor -> OPENPAR expression CLOSEPAR .)
    MOD             reduce using rule 42 (factor -> OPENPAR expression CLOSEPAR .)
    TILDE           reduce using rule 42 (factor -> OPENPAR expression CLOSEPAR .)
    PLUS            reduce using rule 42 (factor -> OPENPAR expression CLOSEPAR .)
    MINUS           reduce using rule 42 (factor -> OPENPAR expression CLOSEPAR .)
    GT              reduce using rule 42 (factor -> OPENPAR expression CLOSEPAR .)
    GEQ             reduce using rule 42 (factor -> OPENPAR expression CLOSEPAR .)
    LT              reduce using rule 42 (factor -> OPENPAR expression CLOSEPAR .)
    LEQ             reduce using rule 42 (factor -> OPENPAR expression CLOSEPAR .)
    EQ              reduce using rule 42 (factor -> OPENPAR expression CLOSEPAR .)
    NEQ             reduce using rule 42 (factor -> OPENPAR expression CLOSEPAR .)
    AND             reduce using rule 42 (factor -> OPENPAR expression CLOSEPAR .)
    OR              reduce using rule 42 (factor -> OPENPAR expression CLOSEPAR .)
    CLOSEPAR        reduce using rule 42 (factor -> OPENPAR expression CLOSEPAR .)


state 58

    (12) statement -> class VAR OPENCURLY . statement CLOSECURLY
    (2) statement -> . empty
    (4) statement -> . statement_list
    (7) statement -> . VAR ASSIGN expression TILDE
    (8) statement -> . expression TILDE
    (9) statement -> . def VAR OPENPAR parameter CLOSEPAR OPENCURLY statement CLOSECURLY end_def
    (12) statement -> . class VAR OPENCURLY statement CLOSECURLY
    (13) statement -> . VAR ASSIGN expression TILDE scan OPENPAR VAR CLOSEPAR TILDE
    (14) statement -> . VAR ASSIGN STRLIT TILDE scan OPENPAR VAR CLOSEPAR TILDE
    (15) statement -> . VAR ASSIGN expression TILDE return OPENPAR VAR CLOSEPAR TILDE
    (16) statement -> . VAR ASSIGN STRLIT TILDE return OPENPAR VAR CLOSEPAR TILDE
    (17) statement -> . print OPENPAR expression CLOSEPAR TILDE
    (18) statement -> . print OPENPAR STRLIT CLOSEPAR TILDE
    (19) statement -> . VAR ASSIGN expression TILDE print OPENPAR VAR CLOSEPAR TILDE
    (20) statement -> . VAR ASSIGN STRLIT TILDE print OPENPAR VAR CLOSEPAR TILDE
    (21) statement -> . if_statement
    (3) empty -> .
    (5) statement_list -> . statement
    (6) statement_list -> . statement statement_list
    (24) expression -> . term
    (25) expression -> . boolean
    (34) expression -> . expression PLUS term
    (35) expression -> . expression MINUS term
    (22) if_statement -> . if OPENPAR boolean CLOSEPAR OPENCURLY statement CLOSECURLY
    (23) if_statement -> . if OPENPAR boolean CLOSEPAR OPENCURLY statement CLOSECURLY else OPENCURLY statement CLOSECURLY
    (36) term -> . term MUL factor
    (37) term -> . term DIV factor
    (38) term -> . term MOD factor
    (39) term -> . STRLIT
    (40) term -> . factor
    (26) boolean -> . expression GT term
    (27) boolean -> . expression GEQ term
    (28) boolean -> . expression LT term
    (29) boolean -> . expression LEQ term
    (30) boolean -> . expression EQ term
    (31) boolean -> . expression NEQ term
    (32) boolean -> . expression AND term
    (33) boolean -> . expression OR term
    (41) factor -> . INTLIT
    (42) factor -> . OPENPAR expression CLOSEPAR

  ! shift/reduce conflict for VAR resolved as shift
  ! shift/reduce conflict for def resolved as shift
  ! shift/reduce conflict for class resolved as shift
  ! shift/reduce conflict for print resolved as shift
  ! shift/reduce conflict for if resolved as shift
  ! shift/reduce conflict for STRLIT resolved as shift
  ! shift/reduce conflict for INTLIT resolved as shift
  ! shift/reduce conflict for OPENPAR resolved as shift
    VAR             shift and go to state 7
    def             shift and go to state 9
    class           shift and go to state 11
    print           shift and go to state 13
    CLOSECURLY      reduce using rule 3 (empty -> .)
    if              shift and go to state 17
    STRLIT          shift and go to state 12
    INTLIT          shift and go to state 19
    OPENPAR         shift and go to state 10

  ! VAR             [ reduce using rule 3 (empty -> .) ]
  ! def             [ reduce using rule 3 (empty -> .) ]
  ! class           [ reduce using rule 3 (empty -> .) ]
  ! print           [ reduce using rule 3 (empty -> .) ]
  ! if              [ reduce using rule 3 (empty -> .) ]
  ! STRLIT          [ reduce using rule 3 (empty -> .) ]
  ! INTLIT          [ reduce using rule 3 (empty -> .) ]
  ! OPENPAR         [ reduce using rule 3 (empty -> .) ]

    statement                      shift and go to state 71
    empty                          shift and go to state 5
    statement_list                 shift and go to state 6
    expression                     shift and go to state 8
    if_statement                   shift and go to state 14
    term                           shift and go to state 15
    boolean                        shift and go to state 16
    factor                         shift and go to state 18

state 59

    (17) statement -> print OPENPAR expression . CLOSEPAR TILDE
    (34) expression -> expression . PLUS term
    (35) expression -> expression . MINUS term
    (26) boolean -> expression . GT term
    (27) boolean -> expression . GEQ term
    (28) boolean -> expression . LT term
    (29) boolean -> expression . LEQ term
    (30) boolean -> expression . EQ term
    (31) boolean -> expression . NEQ term
    (32) boolean -> expression . AND term
    (33) boolean -> expression . OR term

    CLOSEPAR        shift and go to state 72
    PLUS            shift and go to state 25
    MINUS           shift and go to state 26
    GT              shift and go to state 27
    GEQ             shift and go to state 28
    LT              shift and go to state 29
    LEQ             shift and go to state 30
    EQ              shift and go to state 31
    NEQ             shift and go to state 32
    AND             shift and go to state 33
    OR              shift and go to state 34


state 60

    (18) statement -> print OPENPAR STRLIT . CLOSEPAR TILDE
    (39) term -> STRLIT .

  ! shift/reduce conflict for CLOSEPAR resolved as shift
    CLOSEPAR        shift and go to state 73
    MUL             reduce using rule 39 (term -> STRLIT .)
    DIV             reduce using rule 39 (term -> STRLIT .)
    MOD             reduce using rule 39 (term -> STRLIT .)
    PLUS            reduce using rule 39 (term -> STRLIT .)
    MINUS           reduce using rule 39 (term -> STRLIT .)
    GT              reduce using rule 39 (term -> STRLIT .)
    GEQ             reduce using rule 39 (term -> STRLIT .)
    LT              reduce using rule 39 (term -> STRLIT .)
    LEQ             reduce using rule 39 (term -> STRLIT .)
    EQ              reduce using rule 39 (term -> STRLIT .)
    NEQ             reduce using rule 39 (term -> STRLIT .)
    AND             reduce using rule 39 (term -> STRLIT .)
    OR              reduce using rule 39 (term -> STRLIT .)

  ! CLOSEPAR        [ reduce using rule 39 (term -> STRLIT .) ]


state 61

    (36) term -> term MUL factor .

    MUL             reduce using rule 36 (term -> term MUL factor .)
    DIV             reduce using rule 36 (term -> term MUL factor .)
    MOD             reduce using rule 36 (term -> term MUL factor .)
    TILDE           reduce using rule 36 (term -> term MUL factor .)
    PLUS            reduce using rule 36 (term -> term MUL factor .)
    MINUS           reduce using rule 36 (term -> term MUL factor .)
    GT              reduce using rule 36 (term -> term MUL factor .)
    GEQ             reduce using rule 36 (term -> term MUL factor .)
    LT              reduce using rule 36 (term -> term MUL factor .)
    LEQ             reduce using rule 36 (term -> term MUL factor .)
    EQ              reduce using rule 36 (term -> term MUL factor .)
    NEQ             reduce using rule 36 (term -> term MUL factor .)
    AND             reduce using rule 36 (term -> term MUL factor .)
    OR              reduce using rule 36 (term -> term MUL factor .)
    CLOSEPAR        reduce using rule 36 (term -> term MUL factor .)


state 62

    (37) term -> term DIV factor .

    MUL             reduce using rule 37 (term -> term DIV factor .)
    DIV             reduce using rule 37 (term -> term DIV factor .)
    MOD             reduce using rule 37 (term -> term DIV factor .)
    TILDE           reduce using rule 37 (term -> term DIV factor .)
    PLUS            reduce using rule 37 (term -> term DIV factor .)
    MINUS           reduce using rule 37 (term -> term DIV factor .)
    GT              reduce using rule 37 (term -> term DIV factor .)
    GEQ             reduce using rule 37 (term -> term DIV factor .)
    LT              reduce using rule 37 (term -> term DIV factor .)
    LEQ             reduce using rule 37 (term -> term DIV factor .)
    EQ              reduce using rule 37 (term -> term DIV factor .)
    NEQ             reduce using rule 37 (term -> term DIV factor .)
    AND             reduce using rule 37 (term -> term DIV factor .)
    OR              reduce using rule 37 (term -> term DIV factor .)
    CLOSEPAR        reduce using rule 37 (term -> term DIV factor .)


state 63

    (38) term -> term MOD factor .

    MUL             reduce using rule 38 (term -> term MOD factor .)
    DIV             reduce using rule 38 (term -> term MOD factor .)
    MOD             reduce using rule 38 (term -> term MOD factor .)
    TILDE           reduce using rule 38 (term -> term MOD factor .)
    PLUS            reduce using rule 38 (term -> term MOD factor .)
    MINUS           reduce using rule 38 (term -> term MOD factor .)
    GT              reduce using rule 38 (term -> term MOD factor .)
    GEQ             reduce using rule 38 (term -> term MOD factor .)
    LT              reduce using rule 38 (term -> term MOD factor .)
    LEQ             reduce using rule 38 (term -> term MOD factor .)
    EQ              reduce using rule 38 (term -> term MOD factor .)
    NEQ             reduce using rule 38 (term -> term MOD factor .)
    AND             reduce using rule 38 (term -> term MOD factor .)
    OR              reduce using rule 38 (term -> term MOD factor .)
    CLOSEPAR        reduce using rule 38 (term -> term MOD factor .)


state 64

    (22) if_statement -> if OPENPAR boolean . CLOSEPAR OPENCURLY statement CLOSECURLY
    (23) if_statement -> if OPENPAR boolean . CLOSEPAR OPENCURLY statement CLOSECURLY else OPENCURLY statement CLOSECURLY
    (25) expression -> boolean .

    CLOSEPAR        shift and go to state 74
    GT              reduce using rule 25 (expression -> boolean .)
    GEQ             reduce using rule 25 (expression -> boolean .)
    LT              reduce using rule 25 (expression -> boolean .)
    LEQ             reduce using rule 25 (expression -> boolean .)
    EQ              reduce using rule 25 (expression -> boolean .)
    NEQ             reduce using rule 25 (expression -> boolean .)
    AND             reduce using rule 25 (expression -> boolean .)
    OR              reduce using rule 25 (expression -> boolean .)
    PLUS            reduce using rule 25 (expression -> boolean .)
    MINUS           reduce using rule 25 (expression -> boolean .)


state 65

    (26) boolean -> expression . GT term
    (27) boolean -> expression . GEQ term
    (28) boolean -> expression . LT term
    (29) boolean -> expression . LEQ term
    (30) boolean -> expression . EQ term
    (31) boolean -> expression . NEQ term
    (32) boolean -> expression . AND term
    (33) boolean -> expression . OR term
    (34) expression -> expression . PLUS term
    (35) expression -> expression . MINUS term

    GT              shift and go to state 27
    GEQ             shift and go to state 28
    LT              shift and go to state 29
    LEQ             shift and go to state 30
    EQ              shift and go to state 31
    NEQ             shift and go to state 32
    AND             shift and go to state 33
    OR              shift and go to state 34
    PLUS            shift and go to state 25
    MINUS           shift and go to state 26


state 66

    (7) statement -> VAR ASSIGN expression TILDE .
    (13) statement -> VAR ASSIGN expression TILDE . scan OPENPAR VAR CLOSEPAR TILDE
    (15) statement -> VAR ASSIGN expression TILDE . return OPENPAR VAR CLOSEPAR TILDE
    (19) statement -> VAR ASSIGN expression TILDE . print OPENPAR VAR CLOSEPAR TILDE

  ! shift/reduce conflict for print resolved as shift
    CLOSECURLY      reduce using rule 7 (statement -> VAR ASSIGN expression TILDE .)
    VAR             reduce using rule 7 (statement -> VAR ASSIGN expression TILDE .)
    def             reduce using rule 7 (statement -> VAR ASSIGN expression TILDE .)
    class           reduce using rule 7 (statement -> VAR ASSIGN expression TILDE .)
    if              reduce using rule 7 (statement -> VAR ASSIGN expression TILDE .)
    STRLIT          reduce using rule 7 (statement -> VAR ASSIGN expression TILDE .)
    INTLIT          reduce using rule 7 (statement -> VAR ASSIGN expression TILDE .)
    OPENPAR         reduce using rule 7 (statement -> VAR ASSIGN expression TILDE .)
    scan            shift and go to state 75
    return          shift and go to state 76
    print           shift and go to state 77

  ! print           [ reduce using rule 7 (statement -> VAR ASSIGN expression TILDE .) ]


state 67

    (14) statement -> VAR ASSIGN STRLIT TILDE . scan OPENPAR VAR CLOSEPAR TILDE
    (16) statement -> VAR ASSIGN STRLIT TILDE . return OPENPAR VAR CLOSEPAR TILDE
    (20) statement -> VAR ASSIGN STRLIT TILDE . print OPENPAR VAR CLOSEPAR TILDE

    scan            shift and go to state 78
    return          shift and go to state 79
    print           shift and go to state 80


state 68

    (9) statement -> def VAR OPENPAR parameter . CLOSEPAR OPENCURLY statement CLOSECURLY end_def

    CLOSEPAR        shift and go to state 81


state 69

    (10) parameter -> int . VAR

    VAR             shift and go to state 82


state 70

    (11) parameter -> string . VAR

    VAR             shift and go to state 83


state 71

    (12) statement -> class VAR OPENCURLY statement . CLOSECURLY
    (5) statement_list -> statement .
    (6) statement_list -> statement . statement_list
    (5) statement_list -> . statement
    (6) statement_list -> . statement statement_list
    (2) statement -> . empty
    (4) statement -> . statement_list
    (7) statement -> . VAR ASSIGN expression TILDE
    (8) statement -> . expression TILDE
    (9) statement -> . def VAR OPENPAR parameter CLOSEPAR OPENCURLY statement CLOSECURLY end_def
    (12) statement -> . class VAR OPENCURLY statement CLOSECURLY
    (13) statement -> . VAR ASSIGN expression TILDE scan OPENPAR VAR CLOSEPAR TILDE
    (14) statement -> . VAR ASSIGN STRLIT TILDE scan OPENPAR VAR CLOSEPAR TILDE
    (15) statement -> . VAR ASSIGN expression TILDE return OPENPAR VAR CLOSEPAR TILDE
    (16) statement -> . VAR ASSIGN STRLIT TILDE return OPENPAR VAR CLOSEPAR TILDE
    (17) statement -> . print OPENPAR expression CLOSEPAR TILDE
    (18) statement -> . print OPENPAR STRLIT CLOSEPAR TILDE
    (19) statement -> . VAR ASSIGN expression TILDE print OPENPAR VAR CLOSEPAR TILDE
    (20) statement -> . VAR ASSIGN STRLIT TILDE print OPENPAR VAR CLOSEPAR TILDE
    (21) statement -> . if_statement
    (3) empty -> .
    (24) expression -> . term
    (25) expression -> . boolean
    (34) expression -> . expression PLUS term
    (35) expression -> . expression MINUS term
    (22) if_statement -> . if OPENPAR boolean CLOSEPAR OPENCURLY statement CLOSECURLY
    (23) if_statement -> . if OPENPAR boolean CLOSEPAR OPENCURLY statement CLOSECURLY else OPENCURLY statement CLOSECURLY
    (36) term -> . term MUL factor
    (37) term -> . term DIV factor
    (38) term -> . term MOD factor
    (39) term -> . STRLIT
    (40) term -> . factor
    (26) boolean -> . expression GT term
    (27) boolean -> . expression GEQ term
    (28) boolean -> . expression LT term
    (29) boolean -> . expression LEQ term
    (30) boolean -> . expression EQ term
    (31) boolean -> . expression NEQ term
    (32) boolean -> . expression AND term
    (33) boolean -> . expression OR term
    (41) factor -> . INTLIT
    (42) factor -> . OPENPAR expression CLOSEPAR

  ! shift/reduce conflict for CLOSECURLY resolved as shift
  ! shift/reduce conflict for VAR resolved as shift
  ! shift/reduce conflict for def resolved as shift
  ! shift/reduce conflict for class resolved as shift
  ! shift/reduce conflict for print resolved as shift
  ! shift/reduce conflict for CLOSECURLY resolved as shift
  ! shift/reduce conflict for VAR resolved as shift
  ! shift/reduce conflict for def resolved as shift
  ! shift/reduce conflict for class resolved as shift
  ! shift/reduce conflict for print resolved as shift
  ! reduce/reduce conflict for if resolved using rule 3 (empty -> .)
  ! reduce/reduce conflict for STRLIT resolved using rule 3 (empty -> .)
  ! reduce/reduce conflict for INTLIT resolved using rule 3 (empty -> .)
  ! reduce/reduce conflict for OPENPAR resolved using rule 3 (empty -> .)
  ! shift/reduce conflict for if resolved as shift
  ! shift/reduce conflict for STRLIT resolved as shift
  ! shift/reduce conflict for INTLIT resolved as shift
  ! shift/reduce conflict for OPENPAR resolved as shift
    CLOSECURLY      shift and go to state 84
    VAR             shift and go to state 7
    def             shift and go to state 9
    class           shift and go to state 11
    print           shift and go to state 13
    if              shift and go to state 17
    STRLIT          shift and go to state 12
    INTLIT          shift and go to state 19
    OPENPAR         shift and go to state 10

  ! CLOSECURLY      [ reduce using rule 5 (statement_list -> statement .) ]
  ! VAR             [ reduce using rule 5 (statement_list -> statement .) ]
  ! def             [ reduce using rule 5 (statement_list -> statement .) ]
  ! class           [ reduce using rule 5 (statement_list -> statement .) ]
  ! print           [ reduce using rule 5 (statement_list -> statement .) ]
  ! if              [ reduce using rule 5 (statement_list -> statement .) ]
  ! STRLIT          [ reduce using rule 5 (statement_list -> statement .) ]
  ! INTLIT          [ reduce using rule 5 (statement_list -> statement .) ]
  ! OPENPAR         [ reduce using rule 5 (statement_list -> statement .) ]
  ! CLOSECURLY      [ reduce using rule 3 (empty -> .) ]
  ! VAR             [ reduce using rule 3 (empty -> .) ]
  ! def             [ reduce using rule 3 (empty -> .) ]
  ! class           [ reduce using rule 3 (empty -> .) ]
  ! print           [ reduce using rule 3 (empty -> .) ]
  ! if              [ reduce using rule 3 (empty -> .) ]
  ! STRLIT          [ reduce using rule 3 (empty -> .) ]
  ! INTLIT          [ reduce using rule 3 (empty -> .) ]
  ! OPENPAR         [ reduce using rule 3 (empty -> .) ]

    statement                      shift and go to state 20
    statement_list                 shift and go to state 22
    empty                          shift and go to state 5
    expression                     shift and go to state 8
    if_statement                   shift and go to state 14
    term                           shift and go to state 15
    boolean                        shift and go to state 16
    factor                         shift and go to state 18

state 72

    (17) statement -> print OPENPAR expression CLOSEPAR . TILDE

    TILDE           shift and go to state 85


state 73

    (18) statement -> print OPENPAR STRLIT CLOSEPAR . TILDE

    TILDE           shift and go to state 86


state 74

    (22) if_statement -> if OPENPAR boolean CLOSEPAR . OPENCURLY statement CLOSECURLY
    (23) if_statement -> if OPENPAR boolean CLOSEPAR . OPENCURLY statement CLOSECURLY else OPENCURLY statement CLOSECURLY

    OPENCURLY       shift and go to state 87


state 75

    (13) statement -> VAR ASSIGN expression TILDE scan . OPENPAR VAR CLOSEPAR TILDE

    OPENPAR         shift and go to state 88


state 76

    (15) statement -> VAR ASSIGN expression TILDE return . OPENPAR VAR CLOSEPAR TILDE

    OPENPAR         shift and go to state 89


state 77

    (19) statement -> VAR ASSIGN expression TILDE print . OPENPAR VAR CLOSEPAR TILDE

    OPENPAR         shift and go to state 90


state 78

    (14) statement -> VAR ASSIGN STRLIT TILDE scan . OPENPAR VAR CLOSEPAR TILDE

    OPENPAR         shift and go to state 91


state 79

    (16) statement -> VAR ASSIGN STRLIT TILDE return . OPENPAR VAR CLOSEPAR TILDE

    OPENPAR         shift and go to state 92


state 80

    (20) statement -> VAR ASSIGN STRLIT TILDE print . OPENPAR VAR CLOSEPAR TILDE

    OPENPAR         shift and go to state 93


state 81

    (9) statement -> def VAR OPENPAR parameter CLOSEPAR . OPENCURLY statement CLOSECURLY end_def

    OPENCURLY       shift and go to state 94


state 82

    (10) parameter -> int VAR .

    CLOSEPAR        reduce using rule 10 (parameter -> int VAR .)


state 83

    (11) parameter -> string VAR .

    CLOSEPAR        reduce using rule 11 (parameter -> string VAR .)


state 84

    (12) statement -> class VAR OPENCURLY statement CLOSECURLY .

    CLOSECURLY      reduce using rule 12 (statement -> class VAR OPENCURLY statement CLOSECURLY .)
    VAR             reduce using rule 12 (statement -> class VAR OPENCURLY statement CLOSECURLY .)
    def             reduce using rule 12 (statement -> class VAR OPENCURLY statement CLOSECURLY .)
    class           reduce using rule 12 (statement -> class VAR OPENCURLY statement CLOSECURLY .)
    print           reduce using rule 12 (statement -> class VAR OPENCURLY statement CLOSECURLY .)
    if              reduce using rule 12 (statement -> class VAR OPENCURLY statement CLOSECURLY .)
    STRLIT          reduce using rule 12 (statement -> class VAR OPENCURLY statement CLOSECURLY .)
    INTLIT          reduce using rule 12 (statement -> class VAR OPENCURLY statement CLOSECURLY .)
    OPENPAR         reduce using rule 12 (statement -> class VAR OPENCURLY statement CLOSECURLY .)


state 85

    (17) statement -> print OPENPAR expression CLOSEPAR TILDE .

    CLOSECURLY      reduce using rule 17 (statement -> print OPENPAR expression CLOSEPAR TILDE .)
    VAR             reduce using rule 17 (statement -> print OPENPAR expression CLOSEPAR TILDE .)
    def             reduce using rule 17 (statement -> print OPENPAR expression CLOSEPAR TILDE .)
    class           reduce using rule 17 (statement -> print OPENPAR expression CLOSEPAR TILDE .)
    print           reduce using rule 17 (statement -> print OPENPAR expression CLOSEPAR TILDE .)
    if              reduce using rule 17 (statement -> print OPENPAR expression CLOSEPAR TILDE .)
    STRLIT          reduce using rule 17 (statement -> print OPENPAR expression CLOSEPAR TILDE .)
    INTLIT          reduce using rule 17 (statement -> print OPENPAR expression CLOSEPAR TILDE .)
    OPENPAR         reduce using rule 17 (statement -> print OPENPAR expression CLOSEPAR TILDE .)


state 86

    (18) statement -> print OPENPAR STRLIT CLOSEPAR TILDE .

    CLOSECURLY      reduce using rule 18 (statement -> print OPENPAR STRLIT CLOSEPAR TILDE .)
    VAR             reduce using rule 18 (statement -> print OPENPAR STRLIT CLOSEPAR TILDE .)
    def             reduce using rule 18 (statement -> print OPENPAR STRLIT CLOSEPAR TILDE .)
    class           reduce using rule 18 (statement -> print OPENPAR STRLIT CLOSEPAR TILDE .)
    print           reduce using rule 18 (statement -> print OPENPAR STRLIT CLOSEPAR TILDE .)
    if              reduce using rule 18 (statement -> print OPENPAR STRLIT CLOSEPAR TILDE .)
    STRLIT          reduce using rule 18 (statement -> print OPENPAR STRLIT CLOSEPAR TILDE .)
    INTLIT          reduce using rule 18 (statement -> print OPENPAR STRLIT CLOSEPAR TILDE .)
    OPENPAR         reduce using rule 18 (statement -> print OPENPAR STRLIT CLOSEPAR TILDE .)


state 87

    (22) if_statement -> if OPENPAR boolean CLOSEPAR OPENCURLY . statement CLOSECURLY
    (23) if_statement -> if OPENPAR boolean CLOSEPAR OPENCURLY . statement CLOSECURLY else OPENCURLY statement CLOSECURLY
    (2) statement -> . empty
    (4) statement -> . statement_list
    (7) statement -> . VAR ASSIGN expression TILDE
    (8) statement -> . expression TILDE
    (9) statement -> . def VAR OPENPAR parameter CLOSEPAR OPENCURLY statement CLOSECURLY end_def
    (12) statement -> . class VAR OPENCURLY statement CLOSECURLY
    (13) statement -> . VAR ASSIGN expression TILDE scan OPENPAR VAR CLOSEPAR TILDE
    (14) statement -> . VAR ASSIGN STRLIT TILDE scan OPENPAR VAR CLOSEPAR TILDE
    (15) statement -> . VAR ASSIGN expression TILDE return OPENPAR VAR CLOSEPAR TILDE
    (16) statement -> . VAR ASSIGN STRLIT TILDE return OPENPAR VAR CLOSEPAR TILDE
    (17) statement -> . print OPENPAR expression CLOSEPAR TILDE
    (18) statement -> . print OPENPAR STRLIT CLOSEPAR TILDE
    (19) statement -> . VAR ASSIGN expression TILDE print OPENPAR VAR CLOSEPAR TILDE
    (20) statement -> . VAR ASSIGN STRLIT TILDE print OPENPAR VAR CLOSEPAR TILDE
    (21) statement -> . if_statement
    (3) empty -> .
    (5) statement_list -> . statement
    (6) statement_list -> . statement statement_list
    (24) expression -> . term
    (25) expression -> . boolean
    (34) expression -> . expression PLUS term
    (35) expression -> . expression MINUS term
    (22) if_statement -> . if OPENPAR boolean CLOSEPAR OPENCURLY statement CLOSECURLY
    (23) if_statement -> . if OPENPAR boolean CLOSEPAR OPENCURLY statement CLOSECURLY else OPENCURLY statement CLOSECURLY
    (36) term -> . term MUL factor
    (37) term -> . term DIV factor
    (38) term -> . term MOD factor
    (39) term -> . STRLIT
    (40) term -> . factor
    (26) boolean -> . expression GT term
    (27) boolean -> . expression GEQ term
    (28) boolean -> . expression LT term
    (29) boolean -> . expression LEQ term
    (30) boolean -> . expression EQ term
    (31) boolean -> . expression NEQ term
    (32) boolean -> . expression AND term
    (33) boolean -> . expression OR term
    (41) factor -> . INTLIT
    (42) factor -> . OPENPAR expression CLOSEPAR

  ! shift/reduce conflict for VAR resolved as shift
  ! shift/reduce conflict for def resolved as shift
  ! shift/reduce conflict for class resolved as shift
  ! shift/reduce conflict for print resolved as shift
  ! shift/reduce conflict for if resolved as shift
  ! shift/reduce conflict for STRLIT resolved as shift
  ! shift/reduce conflict for INTLIT resolved as shift
  ! shift/reduce conflict for OPENPAR resolved as shift
    VAR             shift and go to state 7
    def             shift and go to state 9
    class           shift and go to state 11
    print           shift and go to state 13
    CLOSECURLY      reduce using rule 3 (empty -> .)
    if              shift and go to state 17
    STRLIT          shift and go to state 12
    INTLIT          shift and go to state 19
    OPENPAR         shift and go to state 10

  ! VAR             [ reduce using rule 3 (empty -> .) ]
  ! def             [ reduce using rule 3 (empty -> .) ]
  ! class           [ reduce using rule 3 (empty -> .) ]
  ! print           [ reduce using rule 3 (empty -> .) ]
  ! if              [ reduce using rule 3 (empty -> .) ]
  ! STRLIT          [ reduce using rule 3 (empty -> .) ]
  ! INTLIT          [ reduce using rule 3 (empty -> .) ]
  ! OPENPAR         [ reduce using rule 3 (empty -> .) ]

    boolean                        shift and go to state 16
    statement                      shift and go to state 95
    empty                          shift and go to state 5
    statement_list                 shift and go to state 6
    expression                     shift and go to state 8
    if_statement                   shift and go to state 14
    term                           shift and go to state 15
    factor                         shift and go to state 18

state 88

    (13) statement -> VAR ASSIGN expression TILDE scan OPENPAR . VAR CLOSEPAR TILDE

    VAR             shift and go to state 96


state 89

    (15) statement -> VAR ASSIGN expression TILDE return OPENPAR . VAR CLOSEPAR TILDE

    VAR             shift and go to state 97


state 90

    (19) statement -> VAR ASSIGN expression TILDE print OPENPAR . VAR CLOSEPAR TILDE

    VAR             shift and go to state 98


state 91

    (14) statement -> VAR ASSIGN STRLIT TILDE scan OPENPAR . VAR CLOSEPAR TILDE

    VAR             shift and go to state 99


state 92

    (16) statement -> VAR ASSIGN STRLIT TILDE return OPENPAR . VAR CLOSEPAR TILDE

    VAR             shift and go to state 100


state 93

    (20) statement -> VAR ASSIGN STRLIT TILDE print OPENPAR . VAR CLOSEPAR TILDE

    VAR             shift and go to state 101


state 94

    (9) statement -> def VAR OPENPAR parameter CLOSEPAR OPENCURLY . statement CLOSECURLY end_def
    (2) statement -> . empty
    (4) statement -> . statement_list
    (7) statement -> . VAR ASSIGN expression TILDE
    (8) statement -> . expression TILDE
    (9) statement -> . def VAR OPENPAR parameter CLOSEPAR OPENCURLY statement CLOSECURLY end_def
    (12) statement -> . class VAR OPENCURLY statement CLOSECURLY
    (13) statement -> . VAR ASSIGN expression TILDE scan OPENPAR VAR CLOSEPAR TILDE
    (14) statement -> . VAR ASSIGN STRLIT TILDE scan OPENPAR VAR CLOSEPAR TILDE
    (15) statement -> . VAR ASSIGN expression TILDE return OPENPAR VAR CLOSEPAR TILDE
    (16) statement -> . VAR ASSIGN STRLIT TILDE return OPENPAR VAR CLOSEPAR TILDE
    (17) statement -> . print OPENPAR expression CLOSEPAR TILDE
    (18) statement -> . print OPENPAR STRLIT CLOSEPAR TILDE
    (19) statement -> . VAR ASSIGN expression TILDE print OPENPAR VAR CLOSEPAR TILDE
    (20) statement -> . VAR ASSIGN STRLIT TILDE print OPENPAR VAR CLOSEPAR TILDE
    (21) statement -> . if_statement
    (3) empty -> .
    (5) statement_list -> . statement
    (6) statement_list -> . statement statement_list
    (24) expression -> . term
    (25) expression -> . boolean
    (34) expression -> . expression PLUS term
    (35) expression -> . expression MINUS term
    (22) if_statement -> . if OPENPAR boolean CLOSEPAR OPENCURLY statement CLOSECURLY
    (23) if_statement -> . if OPENPAR boolean CLOSEPAR OPENCURLY statement CLOSECURLY else OPENCURLY statement CLOSECURLY
    (36) term -> . term MUL factor
    (37) term -> . term DIV factor
    (38) term -> . term MOD factor
    (39) term -> . STRLIT
    (40) term -> . factor
    (26) boolean -> . expression GT term
    (27) boolean -> . expression GEQ term
    (28) boolean -> . expression LT term
    (29) boolean -> . expression LEQ term
    (30) boolean -> . expression EQ term
    (31) boolean -> . expression NEQ term
    (32) boolean -> . expression AND term
    (33) boolean -> . expression OR term
    (41) factor -> . INTLIT
    (42) factor -> . OPENPAR expression CLOSEPAR

  ! shift/reduce conflict for VAR resolved as shift
  ! shift/reduce conflict for def resolved as shift
  ! shift/reduce conflict for class resolved as shift
  ! shift/reduce conflict for print resolved as shift
  ! shift/reduce conflict for if resolved as shift
  ! shift/reduce conflict for STRLIT resolved as shift
  ! shift/reduce conflict for INTLIT resolved as shift
  ! shift/reduce conflict for OPENPAR resolved as shift
    VAR             shift and go to state 7
    def             shift and go to state 9
    class           shift and go to state 11
    print           shift and go to state 13
    CLOSECURLY      reduce using rule 3 (empty -> .)
    if              shift and go to state 17
    STRLIT          shift and go to state 12
    INTLIT          shift and go to state 19
    OPENPAR         shift and go to state 10

  ! VAR             [ reduce using rule 3 (empty -> .) ]
  ! def             [ reduce using rule 3 (empty -> .) ]
  ! class           [ reduce using rule 3 (empty -> .) ]
  ! print           [ reduce using rule 3 (empty -> .) ]
  ! if              [ reduce using rule 3 (empty -> .) ]
  ! STRLIT          [ reduce using rule 3 (empty -> .) ]
  ! INTLIT          [ reduce using rule 3 (empty -> .) ]
  ! OPENPAR         [ reduce using rule 3 (empty -> .) ]

    statement                      shift and go to state 102
    empty                          shift and go to state 5
    statement_list                 shift and go to state 6
    expression                     shift and go to state 8
    if_statement                   shift and go to state 14
    term                           shift and go to state 15
    boolean                        shift and go to state 16
    factor                         shift and go to state 18

state 95

    (22) if_statement -> if OPENPAR boolean CLOSEPAR OPENCURLY statement . CLOSECURLY
    (23) if_statement -> if OPENPAR boolean CLOSEPAR OPENCURLY statement . CLOSECURLY else OPENCURLY statement CLOSECURLY
    (5) statement_list -> statement .
    (6) statement_list -> statement . statement_list
    (5) statement_list -> . statement
    (6) statement_list -> . statement statement_list
    (2) statement -> . empty
    (4) statement -> . statement_list
    (7) statement -> . VAR ASSIGN expression TILDE
    (8) statement -> . expression TILDE
    (9) statement -> . def VAR OPENPAR parameter CLOSEPAR OPENCURLY statement CLOSECURLY end_def
    (12) statement -> . class VAR OPENCURLY statement CLOSECURLY
    (13) statement -> . VAR ASSIGN expression TILDE scan OPENPAR VAR CLOSEPAR TILDE
    (14) statement -> . VAR ASSIGN STRLIT TILDE scan OPENPAR VAR CLOSEPAR TILDE
    (15) statement -> . VAR ASSIGN expression TILDE return OPENPAR VAR CLOSEPAR TILDE
    (16) statement -> . VAR ASSIGN STRLIT TILDE return OPENPAR VAR CLOSEPAR TILDE
    (17) statement -> . print OPENPAR expression CLOSEPAR TILDE
    (18) statement -> . print OPENPAR STRLIT CLOSEPAR TILDE
    (19) statement -> . VAR ASSIGN expression TILDE print OPENPAR VAR CLOSEPAR TILDE
    (20) statement -> . VAR ASSIGN STRLIT TILDE print OPENPAR VAR CLOSEPAR TILDE
    (21) statement -> . if_statement
    (3) empty -> .
    (24) expression -> . term
    (25) expression -> . boolean
    (34) expression -> . expression PLUS term
    (35) expression -> . expression MINUS term
    (22) if_statement -> . if OPENPAR boolean CLOSEPAR OPENCURLY statement CLOSECURLY
    (23) if_statement -> . if OPENPAR boolean CLOSEPAR OPENCURLY statement CLOSECURLY else OPENCURLY statement CLOSECURLY
    (36) term -> . term MUL factor
    (37) term -> . term DIV factor
    (38) term -> . term MOD factor
    (39) term -> . STRLIT
    (40) term -> . factor
    (26) boolean -> . expression GT term
    (27) boolean -> . expression GEQ term
    (28) boolean -> . expression LT term
    (29) boolean -> . expression LEQ term
    (30) boolean -> . expression EQ term
    (31) boolean -> . expression NEQ term
    (32) boolean -> . expression AND term
    (33) boolean -> . expression OR term
    (41) factor -> . INTLIT
    (42) factor -> . OPENPAR expression CLOSEPAR

  ! shift/reduce conflict for CLOSECURLY resolved as shift
  ! shift/reduce conflict for VAR resolved as shift
  ! shift/reduce conflict for def resolved as shift
  ! shift/reduce conflict for class resolved as shift
  ! shift/reduce conflict for print resolved as shift
  ! shift/reduce conflict for CLOSECURLY resolved as shift
  ! shift/reduce conflict for VAR resolved as shift
  ! shift/reduce conflict for def resolved as shift
  ! shift/reduce conflict for class resolved as shift
  ! shift/reduce conflict for print resolved as shift
  ! reduce/reduce conflict for if resolved using rule 3 (empty -> .)
  ! reduce/reduce conflict for STRLIT resolved using rule 3 (empty -> .)
  ! reduce/reduce conflict for INTLIT resolved using rule 3 (empty -> .)
  ! reduce/reduce conflict for OPENPAR resolved using rule 3 (empty -> .)
  ! shift/reduce conflict for if resolved as shift
  ! shift/reduce conflict for STRLIT resolved as shift
  ! shift/reduce conflict for INTLIT resolved as shift
  ! shift/reduce conflict for OPENPAR resolved as shift
    CLOSECURLY      shift and go to state 103
    VAR             shift and go to state 7
    def             shift and go to state 9
    class           shift and go to state 11
    print           shift and go to state 13
    if              shift and go to state 17
    STRLIT          shift and go to state 12
    INTLIT          shift and go to state 19
    OPENPAR         shift and go to state 10

  ! CLOSECURLY      [ reduce using rule 5 (statement_list -> statement .) ]
  ! VAR             [ reduce using rule 5 (statement_list -> statement .) ]
  ! def             [ reduce using rule 5 (statement_list -> statement .) ]
  ! class           [ reduce using rule 5 (statement_list -> statement .) ]
  ! print           [ reduce using rule 5 (statement_list -> statement .) ]
  ! if              [ reduce using rule 5 (statement_list -> statement .) ]
  ! STRLIT          [ reduce using rule 5 (statement_list -> statement .) ]
  ! INTLIT          [ reduce using rule 5 (statement_list -> statement .) ]
  ! OPENPAR         [ reduce using rule 5 (statement_list -> statement .) ]
  ! CLOSECURLY      [ reduce using rule 3 (empty -> .) ]
  ! VAR             [ reduce using rule 3 (empty -> .) ]
  ! def             [ reduce using rule 3 (empty -> .) ]
  ! class           [ reduce using rule 3 (empty -> .) ]
  ! print           [ reduce using rule 3 (empty -> .) ]
  ! if              [ reduce using rule 3 (empty -> .) ]
  ! STRLIT          [ reduce using rule 3 (empty -> .) ]
  ! INTLIT          [ reduce using rule 3 (empty -> .) ]
  ! OPENPAR         [ reduce using rule 3 (empty -> .) ]

    boolean                        shift and go to state 16
    statement                      shift and go to state 20
    statement_list                 shift and go to state 22
    empty                          shift and go to state 5
    expression                     shift and go to state 8
    if_statement                   shift and go to state 14
    term                           shift and go to state 15
    factor                         shift and go to state 18

state 96

    (13) statement -> VAR ASSIGN expression TILDE scan OPENPAR VAR . CLOSEPAR TILDE

    CLOSEPAR        shift and go to state 104


state 97

    (15) statement -> VAR ASSIGN expression TILDE return OPENPAR VAR . CLOSEPAR TILDE

    CLOSEPAR        shift and go to state 105


state 98

    (19) statement -> VAR ASSIGN expression TILDE print OPENPAR VAR . CLOSEPAR TILDE

    CLOSEPAR        shift and go to state 106


state 99

    (14) statement -> VAR ASSIGN STRLIT TILDE scan OPENPAR VAR . CLOSEPAR TILDE

    CLOSEPAR        shift and go to state 107


state 100

    (16) statement -> VAR ASSIGN STRLIT TILDE return OPENPAR VAR . CLOSEPAR TILDE

    CLOSEPAR        shift and go to state 108


state 101

    (20) statement -> VAR ASSIGN STRLIT TILDE print OPENPAR VAR . CLOSEPAR TILDE

    CLOSEPAR        shift and go to state 109


state 102

    (9) statement -> def VAR OPENPAR parameter CLOSEPAR OPENCURLY statement . CLOSECURLY end_def
    (5) statement_list -> statement .
    (6) statement_list -> statement . statement_list
    (5) statement_list -> . statement
    (6) statement_list -> . statement statement_list
    (2) statement -> . empty
    (4) statement -> . statement_list
    (7) statement -> . VAR ASSIGN expression TILDE
    (8) statement -> . expression TILDE
    (9) statement -> . def VAR OPENPAR parameter CLOSEPAR OPENCURLY statement CLOSECURLY end_def
    (12) statement -> . class VAR OPENCURLY statement CLOSECURLY
    (13) statement -> . VAR ASSIGN expression TILDE scan OPENPAR VAR CLOSEPAR TILDE
    (14) statement -> . VAR ASSIGN STRLIT TILDE scan OPENPAR VAR CLOSEPAR TILDE
    (15) statement -> . VAR ASSIGN expression TILDE return OPENPAR VAR CLOSEPAR TILDE
    (16) statement -> . VAR ASSIGN STRLIT TILDE return OPENPAR VAR CLOSEPAR TILDE
    (17) statement -> . print OPENPAR expression CLOSEPAR TILDE
    (18) statement -> . print OPENPAR STRLIT CLOSEPAR TILDE
    (19) statement -> . VAR ASSIGN expression TILDE print OPENPAR VAR CLOSEPAR TILDE
    (20) statement -> . VAR ASSIGN STRLIT TILDE print OPENPAR VAR CLOSEPAR TILDE
    (21) statement -> . if_statement
    (3) empty -> .
    (24) expression -> . term
    (25) expression -> . boolean
    (34) expression -> . expression PLUS term
    (35) expression -> . expression MINUS term
    (22) if_statement -> . if OPENPAR boolean CLOSEPAR OPENCURLY statement CLOSECURLY
    (23) if_statement -> . if OPENPAR boolean CLOSEPAR OPENCURLY statement CLOSECURLY else OPENCURLY statement CLOSECURLY
    (36) term -> . term MUL factor
    (37) term -> . term DIV factor
    (38) term -> . term MOD factor
    (39) term -> . STRLIT
    (40) term -> . factor
    (26) boolean -> . expression GT term
    (27) boolean -> . expression GEQ term
    (28) boolean -> . expression LT term
    (29) boolean -> . expression LEQ term
    (30) boolean -> . expression EQ term
    (31) boolean -> . expression NEQ term
    (32) boolean -> . expression AND term
    (33) boolean -> . expression OR term
    (41) factor -> . INTLIT
    (42) factor -> . OPENPAR expression CLOSEPAR

  ! shift/reduce conflict for CLOSECURLY resolved as shift
  ! shift/reduce conflict for VAR resolved as shift
  ! shift/reduce conflict for def resolved as shift
  ! shift/reduce conflict for class resolved as shift
  ! shift/reduce conflict for print resolved as shift
  ! shift/reduce conflict for CLOSECURLY resolved as shift
  ! shift/reduce conflict for VAR resolved as shift
  ! shift/reduce conflict for def resolved as shift
  ! shift/reduce conflict for class resolved as shift
  ! shift/reduce conflict for print resolved as shift
  ! reduce/reduce conflict for if resolved using rule 3 (empty -> .)
  ! reduce/reduce conflict for STRLIT resolved using rule 3 (empty -> .)
  ! reduce/reduce conflict for INTLIT resolved using rule 3 (empty -> .)
  ! reduce/reduce conflict for OPENPAR resolved using rule 3 (empty -> .)
  ! shift/reduce conflict for if resolved as shift
  ! shift/reduce conflict for STRLIT resolved as shift
  ! shift/reduce conflict for INTLIT resolved as shift
  ! shift/reduce conflict for OPENPAR resolved as shift
    CLOSECURLY      shift and go to state 110
    VAR             shift and go to state 7
    def             shift and go to state 9
    class           shift and go to state 11
    print           shift and go to state 13
    if              shift and go to state 17
    STRLIT          shift and go to state 12
    INTLIT          shift and go to state 19
    OPENPAR         shift and go to state 10

  ! CLOSECURLY      [ reduce using rule 5 (statement_list -> statement .) ]
  ! VAR             [ reduce using rule 5 (statement_list -> statement .) ]
  ! def             [ reduce using rule 5 (statement_list -> statement .) ]
  ! class           [ reduce using rule 5 (statement_list -> statement .) ]
  ! print           [ reduce using rule 5 (statement_list -> statement .) ]
  ! if              [ reduce using rule 5 (statement_list -> statement .) ]
  ! STRLIT          [ reduce using rule 5 (statement_list -> statement .) ]
  ! INTLIT          [ reduce using rule 5 (statement_list -> statement .) ]
  ! OPENPAR         [ reduce using rule 5 (statement_list -> statement .) ]
  ! CLOSECURLY      [ reduce using rule 3 (empty -> .) ]
  ! VAR             [ reduce using rule 3 (empty -> .) ]
  ! def             [ reduce using rule 3 (empty -> .) ]
  ! class           [ reduce using rule 3 (empty -> .) ]
  ! print           [ reduce using rule 3 (empty -> .) ]
  ! if              [ reduce using rule 3 (empty -> .) ]
  ! STRLIT          [ reduce using rule 3 (empty -> .) ]
  ! INTLIT          [ reduce using rule 3 (empty -> .) ]
  ! OPENPAR         [ reduce using rule 3 (empty -> .) ]

    statement                      shift and go to state 20
    statement_list                 shift and go to state 22
    empty                          shift and go to state 5
    expression                     shift and go to state 8
    if_statement                   shift and go to state 14
    term                           shift and go to state 15
    boolean                        shift and go to state 16
    factor                         shift and go to state 18

state 103

    (22) if_statement -> if OPENPAR boolean CLOSEPAR OPENCURLY statement CLOSECURLY .
    (23) if_statement -> if OPENPAR boolean CLOSEPAR OPENCURLY statement CLOSECURLY . else OPENCURLY statement CLOSECURLY

    CLOSECURLY      reduce using rule 22 (if_statement -> if OPENPAR boolean CLOSEPAR OPENCURLY statement CLOSECURLY .)
    VAR             reduce using rule 22 (if_statement -> if OPENPAR boolean CLOSEPAR OPENCURLY statement CLOSECURLY .)
    def             reduce using rule 22 (if_statement -> if OPENPAR boolean CLOSEPAR OPENCURLY statement CLOSECURLY .)
    class           reduce using rule 22 (if_statement -> if OPENPAR boolean CLOSEPAR OPENCURLY statement CLOSECURLY .)
    print           reduce using rule 22 (if_statement -> if OPENPAR boolean CLOSEPAR OPENCURLY statement CLOSECURLY .)
    if              reduce using rule 22 (if_statement -> if OPENPAR boolean CLOSEPAR OPENCURLY statement CLOSECURLY .)
    STRLIT          reduce using rule 22 (if_statement -> if OPENPAR boolean CLOSEPAR OPENCURLY statement CLOSECURLY .)
    INTLIT          reduce using rule 22 (if_statement -> if OPENPAR boolean CLOSEPAR OPENCURLY statement CLOSECURLY .)
    OPENPAR         reduce using rule 22 (if_statement -> if OPENPAR boolean CLOSEPAR OPENCURLY statement CLOSECURLY .)
    else            shift and go to state 111


state 104

    (13) statement -> VAR ASSIGN expression TILDE scan OPENPAR VAR CLOSEPAR . TILDE

    TILDE           shift and go to state 112


state 105

    (15) statement -> VAR ASSIGN expression TILDE return OPENPAR VAR CLOSEPAR . TILDE

    TILDE           shift and go to state 113


state 106

    (19) statement -> VAR ASSIGN expression TILDE print OPENPAR VAR CLOSEPAR . TILDE

    TILDE           shift and go to state 114


state 107

    (14) statement -> VAR ASSIGN STRLIT TILDE scan OPENPAR VAR CLOSEPAR . TILDE

    TILDE           shift and go to state 115


state 108

    (16) statement -> VAR ASSIGN STRLIT TILDE return OPENPAR VAR CLOSEPAR . TILDE

    TILDE           shift and go to state 116


state 109

    (20) statement -> VAR ASSIGN STRLIT TILDE print OPENPAR VAR CLOSEPAR . TILDE

    TILDE           shift and go to state 117


state 110

    (9) statement -> def VAR OPENPAR parameter CLOSEPAR OPENCURLY statement CLOSECURLY . end_def

    end_def         shift and go to state 118


state 111

    (23) if_statement -> if OPENPAR boolean CLOSEPAR OPENCURLY statement CLOSECURLY else . OPENCURLY statement CLOSECURLY

    OPENCURLY       shift and go to state 119


state 112

    (13) statement -> VAR ASSIGN expression TILDE scan OPENPAR VAR CLOSEPAR TILDE .

    CLOSECURLY      reduce using rule 13 (statement -> VAR ASSIGN expression TILDE scan OPENPAR VAR CLOSEPAR TILDE .)
    VAR             reduce using rule 13 (statement -> VAR ASSIGN expression TILDE scan OPENPAR VAR CLOSEPAR TILDE .)
    def             reduce using rule 13 (statement -> VAR ASSIGN expression TILDE scan OPENPAR VAR CLOSEPAR TILDE .)
    class           reduce using rule 13 (statement -> VAR ASSIGN expression TILDE scan OPENPAR VAR CLOSEPAR TILDE .)
    print           reduce using rule 13 (statement -> VAR ASSIGN expression TILDE scan OPENPAR VAR CLOSEPAR TILDE .)
    if              reduce using rule 13 (statement -> VAR ASSIGN expression TILDE scan OPENPAR VAR CLOSEPAR TILDE .)
    STRLIT          reduce using rule 13 (statement -> VAR ASSIGN expression TILDE scan OPENPAR VAR CLOSEPAR TILDE .)
    INTLIT          reduce using rule 13 (statement -> VAR ASSIGN expression TILDE scan OPENPAR VAR CLOSEPAR TILDE .)
    OPENPAR         reduce using rule 13 (statement -> VAR ASSIGN expression TILDE scan OPENPAR VAR CLOSEPAR TILDE .)


state 113

    (15) statement -> VAR ASSIGN expression TILDE return OPENPAR VAR CLOSEPAR TILDE .

    CLOSECURLY      reduce using rule 15 (statement -> VAR ASSIGN expression TILDE return OPENPAR VAR CLOSEPAR TILDE .)
    VAR             reduce using rule 15 (statement -> VAR ASSIGN expression TILDE return OPENPAR VAR CLOSEPAR TILDE .)
    def             reduce using rule 15 (statement -> VAR ASSIGN expression TILDE return OPENPAR VAR CLOSEPAR TILDE .)
    class           reduce using rule 15 (statement -> VAR ASSIGN expression TILDE return OPENPAR VAR CLOSEPAR TILDE .)
    print           reduce using rule 15 (statement -> VAR ASSIGN expression TILDE return OPENPAR VAR CLOSEPAR TILDE .)
    if              reduce using rule 15 (statement -> VAR ASSIGN expression TILDE return OPENPAR VAR CLOSEPAR TILDE .)
    STRLIT          reduce using rule 15 (statement -> VAR ASSIGN expression TILDE return OPENPAR VAR CLOSEPAR TILDE .)
    INTLIT          reduce using rule 15 (statement -> VAR ASSIGN expression TILDE return OPENPAR VAR CLOSEPAR TILDE .)
    OPENPAR         reduce using rule 15 (statement -> VAR ASSIGN expression TILDE return OPENPAR VAR CLOSEPAR TILDE .)


state 114

    (19) statement -> VAR ASSIGN expression TILDE print OPENPAR VAR CLOSEPAR TILDE .

    CLOSECURLY      reduce using rule 19 (statement -> VAR ASSIGN expression TILDE print OPENPAR VAR CLOSEPAR TILDE .)
    VAR             reduce using rule 19 (statement -> VAR ASSIGN expression TILDE print OPENPAR VAR CLOSEPAR TILDE .)
    def             reduce using rule 19 (statement -> VAR ASSIGN expression TILDE print OPENPAR VAR CLOSEPAR TILDE .)
    class           reduce using rule 19 (statement -> VAR ASSIGN expression TILDE print OPENPAR VAR CLOSEPAR TILDE .)
    print           reduce using rule 19 (statement -> VAR ASSIGN expression TILDE print OPENPAR VAR CLOSEPAR TILDE .)
    if              reduce using rule 19 (statement -> VAR ASSIGN expression TILDE print OPENPAR VAR CLOSEPAR TILDE .)
    STRLIT          reduce using rule 19 (statement -> VAR ASSIGN expression TILDE print OPENPAR VAR CLOSEPAR TILDE .)
    INTLIT          reduce using rule 19 (statement -> VAR ASSIGN expression TILDE print OPENPAR VAR CLOSEPAR TILDE .)
    OPENPAR         reduce using rule 19 (statement -> VAR ASSIGN expression TILDE print OPENPAR VAR CLOSEPAR TILDE .)


state 115

    (14) statement -> VAR ASSIGN STRLIT TILDE scan OPENPAR VAR CLOSEPAR TILDE .

    CLOSECURLY      reduce using rule 14 (statement -> VAR ASSIGN STRLIT TILDE scan OPENPAR VAR CLOSEPAR TILDE .)
    VAR             reduce using rule 14 (statement -> VAR ASSIGN STRLIT TILDE scan OPENPAR VAR CLOSEPAR TILDE .)
    def             reduce using rule 14 (statement -> VAR ASSIGN STRLIT TILDE scan OPENPAR VAR CLOSEPAR TILDE .)
    class           reduce using rule 14 (statement -> VAR ASSIGN STRLIT TILDE scan OPENPAR VAR CLOSEPAR TILDE .)
    print           reduce using rule 14 (statement -> VAR ASSIGN STRLIT TILDE scan OPENPAR VAR CLOSEPAR TILDE .)
    if              reduce using rule 14 (statement -> VAR ASSIGN STRLIT TILDE scan OPENPAR VAR CLOSEPAR TILDE .)
    STRLIT          reduce using rule 14 (statement -> VAR ASSIGN STRLIT TILDE scan OPENPAR VAR CLOSEPAR TILDE .)
    INTLIT          reduce using rule 14 (statement -> VAR ASSIGN STRLIT TILDE scan OPENPAR VAR CLOSEPAR TILDE .)
    OPENPAR         reduce using rule 14 (statement -> VAR ASSIGN STRLIT TILDE scan OPENPAR VAR CLOSEPAR TILDE .)


state 116

    (16) statement -> VAR ASSIGN STRLIT TILDE return OPENPAR VAR CLOSEPAR TILDE .

    CLOSECURLY      reduce using rule 16 (statement -> VAR ASSIGN STRLIT TILDE return OPENPAR VAR CLOSEPAR TILDE .)
    VAR             reduce using rule 16 (statement -> VAR ASSIGN STRLIT TILDE return OPENPAR VAR CLOSEPAR TILDE .)
    def             reduce using rule 16 (statement -> VAR ASSIGN STRLIT TILDE return OPENPAR VAR CLOSEPAR TILDE .)
    class           reduce using rule 16 (statement -> VAR ASSIGN STRLIT TILDE return OPENPAR VAR CLOSEPAR TILDE .)
    print           reduce using rule 16 (statement -> VAR ASSIGN STRLIT TILDE return OPENPAR VAR CLOSEPAR TILDE .)
    if              reduce using rule 16 (statement -> VAR ASSIGN STRLIT TILDE return OPENPAR VAR CLOSEPAR TILDE .)
    STRLIT          reduce using rule 16 (statement -> VAR ASSIGN STRLIT TILDE return OPENPAR VAR CLOSEPAR TILDE .)
    INTLIT          reduce using rule 16 (statement -> VAR ASSIGN STRLIT TILDE return OPENPAR VAR CLOSEPAR TILDE .)
    OPENPAR         reduce using rule 16 (statement -> VAR ASSIGN STRLIT TILDE return OPENPAR VAR CLOSEPAR TILDE .)


state 117

    (20) statement -> VAR ASSIGN STRLIT TILDE print OPENPAR VAR CLOSEPAR TILDE .

    CLOSECURLY      reduce using rule 20 (statement -> VAR ASSIGN STRLIT TILDE print OPENPAR VAR CLOSEPAR TILDE .)
    VAR             reduce using rule 20 (statement -> VAR ASSIGN STRLIT TILDE print OPENPAR VAR CLOSEPAR TILDE .)
    def             reduce using rule 20 (statement -> VAR ASSIGN STRLIT TILDE print OPENPAR VAR CLOSEPAR TILDE .)
    class           reduce using rule 20 (statement -> VAR ASSIGN STRLIT TILDE print OPENPAR VAR CLOSEPAR TILDE .)
    print           reduce using rule 20 (statement -> VAR ASSIGN STRLIT TILDE print OPENPAR VAR CLOSEPAR TILDE .)
    if              reduce using rule 20 (statement -> VAR ASSIGN STRLIT TILDE print OPENPAR VAR CLOSEPAR TILDE .)
    STRLIT          reduce using rule 20 (statement -> VAR ASSIGN STRLIT TILDE print OPENPAR VAR CLOSEPAR TILDE .)
    INTLIT          reduce using rule 20 (statement -> VAR ASSIGN STRLIT TILDE print OPENPAR VAR CLOSEPAR TILDE .)
    OPENPAR         reduce using rule 20 (statement -> VAR ASSIGN STRLIT TILDE print OPENPAR VAR CLOSEPAR TILDE .)


state 118

    (9) statement -> def VAR OPENPAR parameter CLOSEPAR OPENCURLY statement CLOSECURLY end_def .

    CLOSECURLY      reduce using rule 9 (statement -> def VAR OPENPAR parameter CLOSEPAR OPENCURLY statement CLOSECURLY end_def .)
    VAR             reduce using rule 9 (statement -> def VAR OPENPAR parameter CLOSEPAR OPENCURLY statement CLOSECURLY end_def .)
    def             reduce using rule 9 (statement -> def VAR OPENPAR parameter CLOSEPAR OPENCURLY statement CLOSECURLY end_def .)
    class           reduce using rule 9 (statement -> def VAR OPENPAR parameter CLOSEPAR OPENCURLY statement CLOSECURLY end_def .)
    print           reduce using rule 9 (statement -> def VAR OPENPAR parameter CLOSEPAR OPENCURLY statement CLOSECURLY end_def .)
    if              reduce using rule 9 (statement -> def VAR OPENPAR parameter CLOSEPAR OPENCURLY statement CLOSECURLY end_def .)
    STRLIT          reduce using rule 9 (statement -> def VAR OPENPAR parameter CLOSEPAR OPENCURLY statement CLOSECURLY end_def .)
    INTLIT          reduce using rule 9 (statement -> def VAR OPENPAR parameter CLOSEPAR OPENCURLY statement CLOSECURLY end_def .)
    OPENPAR         reduce using rule 9 (statement -> def VAR OPENPAR parameter CLOSEPAR OPENCURLY statement CLOSECURLY end_def .)


state 119

    (23) if_statement -> if OPENPAR boolean CLOSEPAR OPENCURLY statement CLOSECURLY else OPENCURLY . statement CLOSECURLY
    (2) statement -> . empty
    (4) statement -> . statement_list
    (7) statement -> . VAR ASSIGN expression TILDE
    (8) statement -> . expression TILDE
    (9) statement -> . def VAR OPENPAR parameter CLOSEPAR OPENCURLY statement CLOSECURLY end_def
    (12) statement -> . class VAR OPENCURLY statement CLOSECURLY
    (13) statement -> . VAR ASSIGN expression TILDE scan OPENPAR VAR CLOSEPAR TILDE
    (14) statement -> . VAR ASSIGN STRLIT TILDE scan OPENPAR VAR CLOSEPAR TILDE
    (15) statement -> . VAR ASSIGN expression TILDE return OPENPAR VAR CLOSEPAR TILDE
    (16) statement -> . VAR ASSIGN STRLIT TILDE return OPENPAR VAR CLOSEPAR TILDE
    (17) statement -> . print OPENPAR expression CLOSEPAR TILDE
    (18) statement -> . print OPENPAR STRLIT CLOSEPAR TILDE
    (19) statement -> . VAR ASSIGN expression TILDE print OPENPAR VAR CLOSEPAR TILDE
    (20) statement -> . VAR ASSIGN STRLIT TILDE print OPENPAR VAR CLOSEPAR TILDE
    (21) statement -> . if_statement
    (3) empty -> .
    (5) statement_list -> . statement
    (6) statement_list -> . statement statement_list
    (24) expression -> . term
    (25) expression -> . boolean
    (34) expression -> . expression PLUS term
    (35) expression -> . expression MINUS term
    (22) if_statement -> . if OPENPAR boolean CLOSEPAR OPENCURLY statement CLOSECURLY
    (23) if_statement -> . if OPENPAR boolean CLOSEPAR OPENCURLY statement CLOSECURLY else OPENCURLY statement CLOSECURLY
    (36) term -> . term MUL factor
    (37) term -> . term DIV factor
    (38) term -> . term MOD factor
    (39) term -> . STRLIT
    (40) term -> . factor
    (26) boolean -> . expression GT term
    (27) boolean -> . expression GEQ term
    (28) boolean -> . expression LT term
    (29) boolean -> . expression LEQ term
    (30) boolean -> . expression EQ term
    (31) boolean -> . expression NEQ term
    (32) boolean -> . expression AND term
    (33) boolean -> . expression OR term
    (41) factor -> . INTLIT
    (42) factor -> . OPENPAR expression CLOSEPAR

  ! shift/reduce conflict for VAR resolved as shift
  ! shift/reduce conflict for def resolved as shift
  ! shift/reduce conflict for class resolved as shift
  ! shift/reduce conflict for print resolved as shift
  ! shift/reduce conflict for if resolved as shift
  ! shift/reduce conflict for STRLIT resolved as shift
  ! shift/reduce conflict for INTLIT resolved as shift
  ! shift/reduce conflict for OPENPAR resolved as shift
    VAR             shift and go to state 7
    def             shift and go to state 9
    class           shift and go to state 11
    print           shift and go to state 13
    CLOSECURLY      reduce using rule 3 (empty -> .)
    if              shift and go to state 17
    STRLIT          shift and go to state 12
    INTLIT          shift and go to state 19
    OPENPAR         shift and go to state 10

  ! VAR             [ reduce using rule 3 (empty -> .) ]
  ! def             [ reduce using rule 3 (empty -> .) ]
  ! class           [ reduce using rule 3 (empty -> .) ]
  ! print           [ reduce using rule 3 (empty -> .) ]
  ! if              [ reduce using rule 3 (empty -> .) ]
  ! STRLIT          [ reduce using rule 3 (empty -> .) ]
  ! INTLIT          [ reduce using rule 3 (empty -> .) ]
  ! OPENPAR         [ reduce using rule 3 (empty -> .) ]

    boolean                        shift and go to state 16
    statement                      shift and go to state 120
    empty                          shift and go to state 5
    statement_list                 shift and go to state 6
    expression                     shift and go to state 8
    if_statement                   shift and go to state 14
    term                           shift and go to state 15
    factor                         shift and go to state 18

state 120

    (23) if_statement -> if OPENPAR boolean CLOSEPAR OPENCURLY statement CLOSECURLY else OPENCURLY statement . CLOSECURLY
    (5) statement_list -> statement .
    (6) statement_list -> statement . statement_list
    (5) statement_list -> . statement
    (6) statement_list -> . statement statement_list
    (2) statement -> . empty
    (4) statement -> . statement_list
    (7) statement -> . VAR ASSIGN expression TILDE
    (8) statement -> . expression TILDE
    (9) statement -> . def VAR OPENPAR parameter CLOSEPAR OPENCURLY statement CLOSECURLY end_def
    (12) statement -> . class VAR OPENCURLY statement CLOSECURLY
    (13) statement -> . VAR ASSIGN expression TILDE scan OPENPAR VAR CLOSEPAR TILDE
    (14) statement -> . VAR ASSIGN STRLIT TILDE scan OPENPAR VAR CLOSEPAR TILDE
    (15) statement -> . VAR ASSIGN expression TILDE return OPENPAR VAR CLOSEPAR TILDE
    (16) statement -> . VAR ASSIGN STRLIT TILDE return OPENPAR VAR CLOSEPAR TILDE
    (17) statement -> . print OPENPAR expression CLOSEPAR TILDE
    (18) statement -> . print OPENPAR STRLIT CLOSEPAR TILDE
    (19) statement -> . VAR ASSIGN expression TILDE print OPENPAR VAR CLOSEPAR TILDE
    (20) statement -> . VAR ASSIGN STRLIT TILDE print OPENPAR VAR CLOSEPAR TILDE
    (21) statement -> . if_statement
    (3) empty -> .
    (24) expression -> . term
    (25) expression -> . boolean
    (34) expression -> . expression PLUS term
    (35) expression -> . expression MINUS term
    (22) if_statement -> . if OPENPAR boolean CLOSEPAR OPENCURLY statement CLOSECURLY
    (23) if_statement -> . if OPENPAR boolean CLOSEPAR OPENCURLY statement CLOSECURLY else OPENCURLY statement CLOSECURLY
    (36) term -> . term MUL factor
    (37) term -> . term DIV factor
    (38) term -> . term MOD factor
    (39) term -> . STRLIT
    (40) term -> . factor
    (26) boolean -> . expression GT term
    (27) boolean -> . expression GEQ term
    (28) boolean -> . expression LT term
    (29) boolean -> . expression LEQ term
    (30) boolean -> . expression EQ term
    (31) boolean -> . expression NEQ term
    (32) boolean -> . expression AND term
    (33) boolean -> . expression OR term
    (41) factor -> . INTLIT
    (42) factor -> . OPENPAR expression CLOSEPAR

  ! shift/reduce conflict for CLOSECURLY resolved as shift
  ! shift/reduce conflict for VAR resolved as shift
  ! shift/reduce conflict for def resolved as shift
  ! shift/reduce conflict for class resolved as shift
  ! shift/reduce conflict for print resolved as shift
  ! shift/reduce conflict for CLOSECURLY resolved as shift
  ! shift/reduce conflict for VAR resolved as shift
  ! shift/reduce conflict for def resolved as shift
  ! shift/reduce conflict for class resolved as shift
  ! shift/reduce conflict for print resolved as shift
  ! reduce/reduce conflict for if resolved using rule 3 (empty -> .)
  ! reduce/reduce conflict for STRLIT resolved using rule 3 (empty -> .)
  ! reduce/reduce conflict for INTLIT resolved using rule 3 (empty -> .)
  ! reduce/reduce conflict for OPENPAR resolved using rule 3 (empty -> .)
  ! shift/reduce conflict for if resolved as shift
  ! shift/reduce conflict for STRLIT resolved as shift
  ! shift/reduce conflict for INTLIT resolved as shift
  ! shift/reduce conflict for OPENPAR resolved as shift
    CLOSECURLY      shift and go to state 121
    VAR             shift and go to state 7
    def             shift and go to state 9
    class           shift and go to state 11
    print           shift and go to state 13
    if              shift and go to state 17
    STRLIT          shift and go to state 12
    INTLIT          shift and go to state 19
    OPENPAR         shift and go to state 10

  ! CLOSECURLY      [ reduce using rule 5 (statement_list -> statement .) ]
  ! VAR             [ reduce using rule 5 (statement_list -> statement .) ]
  ! def             [ reduce using rule 5 (statement_list -> statement .) ]
  ! class           [ reduce using rule 5 (statement_list -> statement .) ]
  ! print           [ reduce using rule 5 (statement_list -> statement .) ]
  ! if              [ reduce using rule 5 (statement_list -> statement .) ]
  ! STRLIT          [ reduce using rule 5 (statement_list -> statement .) ]
  ! INTLIT          [ reduce using rule 5 (statement_list -> statement .) ]
  ! OPENPAR         [ reduce using rule 5 (statement_list -> statement .) ]
  ! CLOSECURLY      [ reduce using rule 3 (empty -> .) ]
  ! VAR             [ reduce using rule 3 (empty -> .) ]
  ! def             [ reduce using rule 3 (empty -> .) ]
  ! class           [ reduce using rule 3 (empty -> .) ]
  ! print           [ reduce using rule 3 (empty -> .) ]
  ! if              [ reduce using rule 3 (empty -> .) ]
  ! STRLIT          [ reduce using rule 3 (empty -> .) ]
  ! INTLIT          [ reduce using rule 3 (empty -> .) ]
  ! OPENPAR         [ reduce using rule 3 (empty -> .) ]

    boolean                        shift and go to state 16
    statement                      shift and go to state 20
    statement_list                 shift and go to state 22
    empty                          shift and go to state 5
    expression                     shift and go to state 8
    if_statement                   shift and go to state 14
    term                           shift and go to state 15
    factor                         shift and go to state 18

state 121

    (23) if_statement -> if OPENPAR boolean CLOSEPAR OPENCURLY statement CLOSECURLY else OPENCURLY statement CLOSECURLY .

    CLOSECURLY      reduce using rule 23 (if_statement -> if OPENPAR boolean CLOSEPAR OPENCURLY statement CLOSECURLY else OPENCURLY statement CLOSECURLY .)
    VAR             reduce using rule 23 (if_statement -> if OPENPAR boolean CLOSEPAR OPENCURLY statement CLOSECURLY else OPENCURLY statement CLOSECURLY .)
    def             reduce using rule 23 (if_statement -> if OPENPAR boolean CLOSEPAR OPENCURLY statement CLOSECURLY else OPENCURLY statement CLOSECURLY .)
    class           reduce using rule 23 (if_statement -> if OPENPAR boolean CLOSEPAR OPENCURLY statement CLOSECURLY else OPENCURLY statement CLOSECURLY .)
    print           reduce using rule 23 (if_statement -> if OPENPAR boolean CLOSEPAR OPENCURLY statement CLOSECURLY else OPENCURLY statement CLOSECURLY .)
    if              reduce using rule 23 (if_statement -> if OPENPAR boolean CLOSEPAR OPENCURLY statement CLOSECURLY else OPENCURLY statement CLOSECURLY .)
    STRLIT          reduce using rule 23 (if_statement -> if OPENPAR boolean CLOSEPAR OPENCURLY statement CLOSECURLY else OPENCURLY statement CLOSECURLY .)
    INTLIT          reduce using rule 23 (if_statement -> if OPENPAR boolean CLOSEPAR OPENCURLY statement CLOSECURLY else OPENCURLY statement CLOSECURLY .)
    OPENPAR         reduce using rule 23 (if_statement -> if OPENPAR boolean CLOSEPAR OPENCURLY statement CLOSECURLY else OPENCURLY statement CLOSECURLY .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for VAR in state 3 resolved as shift
WARNING: shift/reduce conflict for def in state 3 resolved as shift
WARNING: shift/reduce conflict for class in state 3 resolved as shift
WARNING: shift/reduce conflict for print in state 3 resolved as shift
WARNING: shift/reduce conflict for if in state 3 resolved as shift
WARNING: shift/reduce conflict for STRLIT in state 3 resolved as shift
WARNING: shift/reduce conflict for INTLIT in state 3 resolved as shift
WARNING: shift/reduce conflict for OPENPAR in state 3 resolved as shift
WARNING: shift/reduce conflict for CLOSECURLY in state 4 resolved as shift
WARNING: shift/reduce conflict for VAR in state 4 resolved as shift
WARNING: shift/reduce conflict for def in state 4 resolved as shift
WARNING: shift/reduce conflict for class in state 4 resolved as shift
WARNING: shift/reduce conflict for print in state 4 resolved as shift
WARNING: shift/reduce conflict for CLOSECURLY in state 4 resolved as shift
WARNING: shift/reduce conflict for VAR in state 4 resolved as shift
WARNING: shift/reduce conflict for def in state 4 resolved as shift
WARNING: shift/reduce conflict for class in state 4 resolved as shift
WARNING: shift/reduce conflict for print in state 4 resolved as shift
WARNING: shift/reduce conflict for if in state 4 resolved as shift
WARNING: shift/reduce conflict for STRLIT in state 4 resolved as shift
WARNING: shift/reduce conflict for INTLIT in state 4 resolved as shift
WARNING: shift/reduce conflict for OPENPAR in state 4 resolved as shift
WARNING: shift/reduce conflict for VAR in state 20 resolved as shift
WARNING: shift/reduce conflict for def in state 20 resolved as shift
WARNING: shift/reduce conflict for class in state 20 resolved as shift
WARNING: shift/reduce conflict for print in state 20 resolved as shift
WARNING: shift/reduce conflict for VAR in state 20 resolved as shift
WARNING: shift/reduce conflict for def in state 20 resolved as shift
WARNING: shift/reduce conflict for class in state 20 resolved as shift
WARNING: shift/reduce conflict for print in state 20 resolved as shift
WARNING: shift/reduce conflict for if in state 20 resolved as shift
WARNING: shift/reduce conflict for STRLIT in state 20 resolved as shift
WARNING: shift/reduce conflict for INTLIT in state 20 resolved as shift
WARNING: shift/reduce conflict for OPENPAR in state 20 resolved as shift
WARNING: shift/reduce conflict for TILDE in state 45 resolved as shift
WARNING: shift/reduce conflict for VAR in state 58 resolved as shift
WARNING: shift/reduce conflict for def in state 58 resolved as shift
WARNING: shift/reduce conflict for class in state 58 resolved as shift
WARNING: shift/reduce conflict for print in state 58 resolved as shift
WARNING: shift/reduce conflict for if in state 58 resolved as shift
WARNING: shift/reduce conflict for STRLIT in state 58 resolved as shift
WARNING: shift/reduce conflict for INTLIT in state 58 resolved as shift
WARNING: shift/reduce conflict for OPENPAR in state 58 resolved as shift
WARNING: shift/reduce conflict for CLOSEPAR in state 60 resolved as shift
WARNING: shift/reduce conflict for print in state 66 resolved as shift
WARNING: shift/reduce conflict for CLOSECURLY in state 71 resolved as shift
WARNING: shift/reduce conflict for VAR in state 71 resolved as shift
WARNING: shift/reduce conflict for def in state 71 resolved as shift
WARNING: shift/reduce conflict for class in state 71 resolved as shift
WARNING: shift/reduce conflict for print in state 71 resolved as shift
WARNING: shift/reduce conflict for CLOSECURLY in state 71 resolved as shift
WARNING: shift/reduce conflict for VAR in state 71 resolved as shift
WARNING: shift/reduce conflict for def in state 71 resolved as shift
WARNING: shift/reduce conflict for class in state 71 resolved as shift
WARNING: shift/reduce conflict for print in state 71 resolved as shift
WARNING: shift/reduce conflict for if in state 71 resolved as shift
WARNING: shift/reduce conflict for STRLIT in state 71 resolved as shift
WARNING: shift/reduce conflict for INTLIT in state 71 resolved as shift
WARNING: shift/reduce conflict for OPENPAR in state 71 resolved as shift
WARNING: shift/reduce conflict for VAR in state 87 resolved as shift
WARNING: shift/reduce conflict for def in state 87 resolved as shift
WARNING: shift/reduce conflict for class in state 87 resolved as shift
WARNING: shift/reduce conflict for print in state 87 resolved as shift
WARNING: shift/reduce conflict for if in state 87 resolved as shift
WARNING: shift/reduce conflict for STRLIT in state 87 resolved as shift
WARNING: shift/reduce conflict for INTLIT in state 87 resolved as shift
WARNING: shift/reduce conflict for OPENPAR in state 87 resolved as shift
WARNING: shift/reduce conflict for VAR in state 94 resolved as shift
WARNING: shift/reduce conflict for def in state 94 resolved as shift
WARNING: shift/reduce conflict for class in state 94 resolved as shift
WARNING: shift/reduce conflict for print in state 94 resolved as shift
WARNING: shift/reduce conflict for if in state 94 resolved as shift
WARNING: shift/reduce conflict for STRLIT in state 94 resolved as shift
WARNING: shift/reduce conflict for INTLIT in state 94 resolved as shift
WARNING: shift/reduce conflict for OPENPAR in state 94 resolved as shift
WARNING: shift/reduce conflict for CLOSECURLY in state 95 resolved as shift
WARNING: shift/reduce conflict for VAR in state 95 resolved as shift
WARNING: shift/reduce conflict for def in state 95 resolved as shift
WARNING: shift/reduce conflict for class in state 95 resolved as shift
WARNING: shift/reduce conflict for print in state 95 resolved as shift
WARNING: shift/reduce conflict for CLOSECURLY in state 95 resolved as shift
WARNING: shift/reduce conflict for VAR in state 95 resolved as shift
WARNING: shift/reduce conflict for def in state 95 resolved as shift
WARNING: shift/reduce conflict for class in state 95 resolved as shift
WARNING: shift/reduce conflict for print in state 95 resolved as shift
WARNING: shift/reduce conflict for if in state 95 resolved as shift
WARNING: shift/reduce conflict for STRLIT in state 95 resolved as shift
WARNING: shift/reduce conflict for INTLIT in state 95 resolved as shift
WARNING: shift/reduce conflict for OPENPAR in state 95 resolved as shift
WARNING: shift/reduce conflict for CLOSECURLY in state 102 resolved as shift
WARNING: shift/reduce conflict for VAR in state 102 resolved as shift
WARNING: shift/reduce conflict for def in state 102 resolved as shift
WARNING: shift/reduce conflict for class in state 102 resolved as shift
WARNING: shift/reduce conflict for print in state 102 resolved as shift
WARNING: shift/reduce conflict for CLOSECURLY in state 102 resolved as shift
WARNING: shift/reduce conflict for VAR in state 102 resolved as shift
WARNING: shift/reduce conflict for def in state 102 resolved as shift
WARNING: shift/reduce conflict for class in state 102 resolved as shift
WARNING: shift/reduce conflict for print in state 102 resolved as shift
WARNING: shift/reduce conflict for if in state 102 resolved as shift
WARNING: shift/reduce conflict for STRLIT in state 102 resolved as shift
WARNING: shift/reduce conflict for INTLIT in state 102 resolved as shift
WARNING: shift/reduce conflict for OPENPAR in state 102 resolved as shift
WARNING: shift/reduce conflict for VAR in state 119 resolved as shift
WARNING: shift/reduce conflict for def in state 119 resolved as shift
WARNING: shift/reduce conflict for class in state 119 resolved as shift
WARNING: shift/reduce conflict for print in state 119 resolved as shift
WARNING: shift/reduce conflict for if in state 119 resolved as shift
WARNING: shift/reduce conflict for STRLIT in state 119 resolved as shift
WARNING: shift/reduce conflict for INTLIT in state 119 resolved as shift
WARNING: shift/reduce conflict for OPENPAR in state 119 resolved as shift
WARNING: shift/reduce conflict for CLOSECURLY in state 120 resolved as shift
WARNING: shift/reduce conflict for VAR in state 120 resolved as shift
WARNING: shift/reduce conflict for def in state 120 resolved as shift
WARNING: shift/reduce conflict for class in state 120 resolved as shift
WARNING: shift/reduce conflict for print in state 120 resolved as shift
WARNING: shift/reduce conflict for CLOSECURLY in state 120 resolved as shift
WARNING: shift/reduce conflict for VAR in state 120 resolved as shift
WARNING: shift/reduce conflict for def in state 120 resolved as shift
WARNING: shift/reduce conflict for class in state 120 resolved as shift
WARNING: shift/reduce conflict for print in state 120 resolved as shift
WARNING: shift/reduce conflict for if in state 120 resolved as shift
WARNING: shift/reduce conflict for STRLIT in state 120 resolved as shift
WARNING: shift/reduce conflict for INTLIT in state 120 resolved as shift
WARNING: shift/reduce conflict for OPENPAR in state 120 resolved as shift
WARNING: reduce/reduce conflict in state 4 resolved using rule (empty -> <empty>)
WARNING: rejected rule (statement_list -> statement) in state 4
WARNING: reduce/reduce conflict in state 20 resolved using rule (empty -> <empty>)
WARNING: rejected rule (statement_list -> statement) in state 20
WARNING: reduce/reduce conflict in state 22 resolved using rule (statement -> statement_list)
WARNING: rejected rule (statement_list -> statement statement_list) in state 22
WARNING: reduce/reduce conflict in state 71 resolved using rule (empty -> <empty>)
WARNING: rejected rule (statement_list -> statement) in state 71
WARNING: reduce/reduce conflict in state 95 resolved using rule (empty -> <empty>)
WARNING: rejected rule (statement_list -> statement) in state 95
WARNING: reduce/reduce conflict in state 102 resolved using rule (empty -> <empty>)
WARNING: rejected rule (statement_list -> statement) in state 102
WARNING: reduce/reduce conflict in state 120 resolved using rule (empty -> <empty>)
WARNING: rejected rule (statement_list -> statement) in state 120
WARNING: Rule (statement_list -> statement) is never reduced
WARNING: Rule (statement_list -> statement statement_list) is never reduced
